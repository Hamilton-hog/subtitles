So, I think that's it for functions.
Now we've talked about functions, arguments, return values.
We talked about variables, constants, data types, and keywords in Dart.
These are such important parts of learning how to program with Dart and Flutter that
I think you need to spend some time and experiment with them.
Do some experimentations on your own.
Don't take just the first name and last name.
Just take, for instance, someone's address, someone's age,
play around a little bit with different data types like integers, different numbers.
Have a look at the link that I provided earlier, which was here.
I'll bring it up again so you can see that.
Have a look at this link and have a look at the different examples of different data types.
Because in the upcoming chapters and in the rest of this course,
we're going to play around with a lot of different types of data types.
I think it's important that you have a look a little bit at the documentation as well.
Let's leave this chapter at this point, and then in the next chapter,
we're going to talk a lot more about more advanced Dart programming language features.
Thank you for joining me for this chapter and see you in the next one.
Hello, everyone, and welcome to chapter four of this Flutter course.
In the previous chapter, chapter three, we talked about keywords, data types, constants,
variables, and some basics of functions.
In this chapter, we are going to, as you can see on the captions here,
we're going to focus on control statements and collections.
Now, I'm assuming you're following these chapters chronologically so that you're going
one by one. I'm assuming then that you have your Dart project set up and that you've got
some sort of a simulator or emulator running. Without further ado, let's have a look at...
I'm actually going to bring up the captions here, and then I'm going to put my face at
the bottom there and bring up our project that we created in the previous chapter up here.
This is running at the moment. If I do a command S or a control S on Linux and Windows,
then as you can see here, there is a run button.
Then it's just going to do a hot reload, which in turn calls this build function,
which we don't yet know really how it works because I haven't really explained it.
But what we did, we just called a print function here and then our get full name function.
What I'm going to do here is let's remove this code from the build,
and let's remove everything that we wrote here as well. Keep the main function,
as you can see here, and then keep your stateless widget, which we're going to talk about later.
Instead, go and create a new function that is called void test.
And then in the build function, just say test. Just like that.
The purpose is that in this function, we're going to write most of the code in this chapter.
We are going to basically test some code. That's the purpose of this function.
Let's talk about if and else. If and else are control statements in most programming languages
that allow you to branch your code based on a condition. So if we, for instance,
in here create a final variable whose value cannot be changed, if you remember from the
previous chapter, whose value cannot be changed after it's been assigned to,
let's say final name is foo, and end it with a semicolon. Now, an if statement basically allows
you to check the value or a condition to be of a certain value or to be true or false, and then it
allows you to execute some code, and then you can also append an else statement to it, which gets
executed if the code or if that condition is not met. I'm going to show you how that is written.
The syntax for an if statement is just if, and if is a keyword. So you would say if,
and then you would open and close parentheses, and then you would put curly brackets like this.
That's the syntax of if. And in the parentheses, you would put your condition.
So I would say in this case if name, and I would like to, for instance, check if name is foo.
Now, we haven't come to operators yet. We're going to talk about operators actually soon.
But this is, as you can see here, we're saying final name equal to foo. This is kind of like
an assignment operation, and that is an operator. In Dart, it's called an operator. So there is
also, and since this is an assignment, we don't want to actually assign anything to name. We want
to check if it's of a certain value, and that is with this conditional operator. Equal, equal.
And then you would just say, okay, if it's foo, then, for instance, print.
Yes, this is foo. And then a semicolon to end it. However, if this condition is not met,
you may want to execute another piece of code, and then you can just do else. Like that.
Then you would just say, no, this is not foo. And a semicolon. So I'm just going to do command S,
and you can see the value or the string, yes, this is foo printed to the screen,
or to the terminal here, or to the debug console. You can have multiple statements in here. So you
can have more print statements in here. You can just do anything you want basically in here.
And the same goes for else. Now, there is a possibility to write if statements kind of
without the curly brackets, but you don't see them that often, and I recommend that you actually
always try to, as a convention, do with the curly brackets if you can. However, it is possible that
inside a code base that you will work on with your colleagues, it is decided that it's okay to have
if statements without curly brackets where they are very simple and one-liners, basically.
So let me show you an example of that. You could just say, if name is foo,
and you would just say print, yes, this is foo. And this is completely accepted as well,
because it's a one-liner. But if you then say, okay, I want to have another line, print hello world,
you can see it goes to the next line, meaning that this line right here will be executed no matter
your condition up there. So this is completely detached from your if statement up here.
I just realized that it is quite important for me to be able to show line numbers.
And by default, your editor probably has line numbers enabled. I usually disable line numbers
when I'm working myself, basically. But when talking about code with other people,
it's quite useful to have line numbers, because I can then tell you, oh, look at line nine or
look at line 10. Okay. So that's the basic of if and else. Now, you can also have if right after
else. So an example of that is, for instance, to say if name is foo, and then you do some code,
all right? You say print, yes, it is foo. Not food. After the curly bracket, then you would say
else. And then you can then say another if, else if. All right? And then after if comes the
parenthesis and a curly bracket, if you remember from the if before. It is the exact same syntax
as it is here. So there's pretty much no difference. You can see if and then if.
And then you put your condition in here. You would just say if name. And then you may just want to
say is not. And that's another operator. It's basically is a not operator. So it's checking
to make sure that this name is not of the value that you provide to the right-hand side.
And then you can say bar. And print. This value is not bar. Else. And then you can wrap it up,
and you can say print. I don't know what this is. Now, I'm so glad I actually accidentally ran into
this issue. As you can see now, the editor is kind of going crazy, and Dart's not understanding
and Dart's not understanding what this statement is. And as we talked about it previously,
strings in Dart are preferred to have to be kind of like created with single codes. However,
if your string in itself contains a single code, for instance, in this case, the word don't
contains a single code, then Dart kind of gets confused. Like, okay, does the string end here?
You can see up until this point, it's green. So it's thinking, oh, the string ends here,
but what is all of this then? That follows. If you have that problem, there are two ways of
fixing that. Either you escape your single code, and that is a software kind of development lingo.
Escape. If you hear that, it pretty much just means that you are kind of wrapping it in a way
that Dart understands that you don't mean it literally. You don't mean that I want to
end my string here, except that this needs to be escaped and put in the string as its own value.
Basically, it's kind of difficult to explain, but I think you know what I mean. So that's one way
of doing it. It's a little bit dirty. So in case you run into this issue, it's best to actually
wrap your entire string in double quotes. And this way, then Dart understands that whatever
comes in here is okay. Like a single code is completely okay. Unless you actually want to have
a double quotes in your string that is enclosed with double quotes again. So you'll see if I
put a double quote here, then Dart goes crazy. So you can escape it with a backslash like that.
So if you have single quotes and double quotes in your string, then you will have to kind of
pick a convention. Either you enclose the entire string in single quotes and escape your single
quotes inside that string and let the double quotes live, or you enclose your entire string
in double quotes and then you will escape your double quotes in the string. I hope that makes
sense. So that is if and else in a nutshell. But before I move on, I kind of want to explain
an important concept here in that when Dart executes this code, it kind of goes by line by
line. So it starts with line seven, the execution of this test function. Then it comes here and
it says, okay, name is foo, all right. And it's actually saying that we prefer const. So let me
change that to const. And it says, okay, if name is foo, all right, then it comes over here. But
let's just change that to foo with triple o. Actually, yeah, no, let's not do that. Let's
keep it as foo. So it says if name is foo. Then it says, yeah, that's true. And then it goes here.
However, as you can see, the line number 11 also says if name is not bar, then it should execute
this as well. And you can see that foo is not bar. So this condition is also true. However,
this will never be executed. And that is because when Dart goes inside these curly brackets,
then it says, okay, I did what I had to do. I did my print statement. The rest I ignore.
So an if statement is kind of like, it puts a stop. When it falls into one of these if statements,
it kind of says, okay, I did my job in this entire if else block, then I will execute the code after
that. So if I clear the console here and press command S, you can see it only says yes, it is foo.
It doesn't come here. However, if you change this condition so that the Dart compiler or
basically the execution of the program doesn't fall into line number 10, it will eventually fall
to line number 12. So you can see it says this value is not bar. So when you're writing your if
statement and else statements, just be careful with that. Just know that it's kind of like as
soon as the code jumps into one of those branches, it doesn't go to the rest of the branches and
checks them basically. All right. Okay. That was for if and else. Now let me check that in my notes
that we've talked about that. What we need to do now is to talk about operators. Operators,
there are three different types of operators. There are prefix operators, infix operators,
and suffix operators. And I will explain them to you how they work. I think to explain operators
probably is best that we talk about numbers. So let's go in this test function and delete
in this test function and delete everything that we've written here. And let me just say final
age is 20. All right. So now we created a variable whose value cannot be changed after
it's been assigned to because we create as a final a variable whose value is 20. All right.
Now if you want to calculate half of this value, how would you do that? Well, there is an operator
for that and that is a division operator. So you would just say, for instance, final half of age.
As you can see, we're using camel case as I explained in the previous chapter. An easy way
to do camel case is to say half of age is writing in English, change the first letter of like this
here. Change the first letter of all the words except for the first word to uppercase and then
remove all the spaces. That's camel case. So half of age is age. And then there is a great
operator in Dart called a division operator. And then you would say two. All right. And then
you could just say print half of age. So command S. And that says 10. All right. So that's the
division operator. And then you will have, let's say, final double the age.
And then we will say age multiplied by two. It's kind of like a star. That is an operator. And you
can see these both operators, this one, the division and the multiplication, multiplication,
it's a bit difficult to say, operators are infix operators. And an infix operator is an operator
that has two parameters, one to its right and one to its left. I don't know how you can actually,
yeah, one to each side. I don't know if my video is mirrored. So if my right hand is actually
right hand on your side as well. So I don't know. Yes, it is probably. So
these are infix operators when they have two values, one to each side. However, they're also
prefix operators. And an example of that is, for instance, if I said final, age minus one.
Actually, we change this to var. I'll explain soon why. And if we said minus, minus age,
now, this is an example of a prefix operator. And a prefix operator is an operator that
it comes before whatever it has to do its work on. And in this case, this minus,
minus operator, what it does is that it takes the value that comes after it,
it decreases that value by one, and then it returns its result back to the left-hand side.
So in this case, the interpreter comes here and says, okay, you want to calculate something.
Okay. It's equal to, oh, a prefix operator that takes a variable here. And it says, okay,
what is age? It's 20. Minus one is 19. Puts it in here. And it also puts that 19 in an age. So
I think so, at least. So if we say print age and print age minus one, now both should kind of be
19. And you can see it says twice. You see two, 19. So that kind of means it's twice. So Flutter
has this great ability not to duplicate, basically, log statements or print statements.
So we have, I mean, there are some really great operators in Dart. And that is the plus operator.
And then you have the minus division multiplication. And then you have the logical
operators to check if a value from the left is equal to the value to the right. So
these are the basics of the operators in Dart. So you don't have to know so much more about these
for now. I would say you can get really far with these. And a lot of these operators actually work
not only on numbers, but also on strings. And for instance, this is one of the cool features of Dart,
which I absolutely love. I think it was just such a great idea for them to implement this.
If you're not coming from a software development background, you may not know this. But if you're
coming, for instance, from a design background, also, you would notice that sometimes when you're
creating designs or any screen and you want to show that design to someone, like a product owner,
you want to actually populate the text inside your design with some lorem ipsum.
And lorem ipsum basically has a huge history of where it comes from. But it's usually some sort
of a dummy text that you want to place inside your design so that you can display and show it to
someone. And a lot of developers, like in many languages, when they want to display some text
and they don't know what to say, like, we're just testing stuff. I just want to display some text.
They go and grab lorem ipsum and then put it in their code. But Dart has gone to the next step
and said, OK, we don't need that. So what you can do, you can say, for instance, name is foo.
That's a string name. But you can say name times 20 is name times 20. You can literally say multiply
a string by 20. And what that does is that it says foo 20 times. So if I say print name times 20,
you can see it says foo 20 times. So it's a great feature. You can say foo, bar,
baz, and then just say times 100. And yeah, it just, that's it,
copies it for you 100 times in names time 100, for instance. So that is a, that is
shortly said, that is the basics of operators in Dart. OK, I'm going to delete that code.
I'm going to mark in my notes that we've talked about that. Now, I'm just going to quickly also
mention that we can also create custom operators, to be honest with you. And I don't think it is
completely all right right now to talk about custom operators. I think it's kind of like a topic to
talk about later. So I actually just moved it in my notes that we don't need to talk about it right
now because we have to know a little bit about classes and objects so that we can,
after we've created our own class, then we can create custom operators as well. So
I don't think it's completely appropriate to talk about right now. But just know that
in the future, you can also create your own operators and then like, or you can also
override like different operators and how they work with different objects. So it is really fun.
But that's that. Let's just leave operators to that for now.
Now, the next topic that I wanted to talk about is lists.
And lists in Dart is a series of things that are similar to each other and they are placed inside
a list, as you would have, for instance, on a piece of paper and you could write your shopping
list or like a Christmas shopping list or whatever, and it's numbered. So these are called lists in
Dart. So for instance, if you say foo, and then bar, and then baz. As you can see, Dart doesn't
like this syntax at the moment. It says, okay, what are these? Like, what is this
comma here? The way to tell Dart that this is a list of things that are like in place one,
two, three is by placing them inside square brackets and then a semicolon, of course.
Now, as I've talked about it before, just now, actually, lists have indexes in that they all
have their own placement inside the list. All these objects, as we call them, they have their
placements inside the list. And you may think that object number one is foo and then object number
two is bar and number three is baz. And that's correct. But indexes in, I mean, all the programming
languages that I've worked with, C++, C, Rust, Dart, Swift, JavaScript, they pretty much all
start at the index of zero. And that is so important to understand because like the placement
of this object called foo inside this list is not one. Its index is zero. And that is why lists are
called zero-based and their indexes are called zero-based indexes. So you've got to be careful
with that. And we're going to talk about indexes soon, actually. So let's just say final names is
that. Now, if I want to extract foo from here, I'm just going to say final foo is names at the
index of zero, right? And I'm just going to print it. I'm just going to say print foo. And you'll
see foo printed here. Now, if I say I want to get baz, then I'm going to say print, sorry,
index of three. And you'll see, oh, sorry, index of three. And you'll see, oh, sorry,
index of two, because it's the third item. But since indexes are zero-based, then it's index of
two. I made the mistake myself. So command S and you'll get baz. And I actually want to go back to
this three and then command S. So you can see what happened here. You'll see you'll get something
called a range error, which is an exception, an exception in Dart and many other programming
languages is when things go wrong so that the language doesn't really know anymore what you
mean. And in this case, you can see this through an exception at the language level or at the
library's level where it says, there are no four items in this array or in this list, because the
index of three indicates four items. Item number one in the list has the index of zero, and then
items. Item number two has the index of one. Item number three has the index of two. And item
number four has the index of three. And there are only three objects in this array or in this list.
So index zero, one, two. So that's it. And index of number three is non-existent. And that is why
we're getting this invalid value, not in inclusive range zero to two. So that's how you access items
inside a list. And this is how you actually create a list, okay? So you say list of items,
which is full bar baz. So you can also, there are some convenient properties on lists that you can,
for instance, say, final length. So if you want to know how many items are in this list, you can
also say names, dot, and then you would say length. And we're going to talk a little bit about dot now
as well, because I think it's so important to understand what dot is. Dot in Dart and in many
other programming languages is a way to drill in to something to extract something else from it.
And in this case, names is a list. And all lists in Dart have something called properties. Length
is a property of the list data type in Dart. And that means every list in Dart has a property
called length that is automatically calculated for you. You don't have to do anything. As you
enter values in this list, this length is going to then return the right value to you. So I'm just
going to talk about that a little bit more. So I'm just going to say print names length. It's going
to say, you'll see here, let me scroll a little bit, it'll say three, three items in this array.
I'm going to change the names list to var so that we can actually
change its contents and mutate it. I just want to add a new name to this names. And I will just say
add. It's a function, as you can see, because it has parentheses right after it. And I will say
my name. And then semicolon to end the statement. Now, if I say print names length right after this
statement, you guessed it. Oh, I can see, actually, you may not see all the print statements
because this text is right there. So let me resize my Visual Studio code a little bit so you can see
things a little bit better. Sorry about that. So now we have names length here. And you can see
the second time around it said four. So when you say dot after the name of a variable,
and that means it can be a constant, a variable, or a final variable, after you put dot
after its name, you're accessing different properties or different functions inside that
thing. So it's kind of like an accessor. It allows you to drill down inside an object and grab things
out of it, or maybe make that object do something for you. So I think that's good enough, to be
honest with you, about lists. I don't want to go too much into details and scare people about
all the different things you can do with lists. But there is great documentation on Dart's own
website. All you have to do is just to Google or duck, duck, go, or whatever you want to use, bing
your way through and just search for dart arrays documentation, or just dart arrays, and then you
will find lots of information about it. Or sorry, dart lists, because in dart they're actually
called lists. In some other programming languages they are called arrays, but those names can be
used interchangeably, to be honest with you. Lists and arrays are kind of like almost the same thing.
So all right, that was lists in dart. I'm going to take it in my notes so that we know we've talked
about it. The next topic that I want to talk about in this video are things called sets.
All right, and as you can see in the caption I've written here is a list of unique things.
Whereas lists were lists of homogeneous things, sets are lists of unique things. So
I think the best way actually to explain sets is just to jump right into it.
So the syntax for set is with a curly bracket. Actually, I think it is.
Yeah, I think so. So let's say final names, and I'm just going to say curly bracket foo,
and then end that. Okay, just like that. Now if I type names here, you will see that the suggestion
provided here, or the information provided by Visual Studio Code says names is a set of string.
We talked about this in the previous chapter, that when I say final names,
or final something, name, for instance, is foo, I'm kind of telling Dart to create a variable
whose reference name is name, and its value is foo, and Dart automatically understand that the
data type of this value is string, because its data is string. So you don't have to say final string
is string. Although you could do that, but let's change this to const as well.
You don't have to actually say this is a string, because Dart understands it automatically.
So you just remove the data type if that's what you want to do, which is what I actually prefer
to do instead of being too verbose, unless you have a really good reason to provide the data type.
Anyways, let's go back to sets. So we were here. And in the same way that we created a string,
and then Dart automatically understood the data type, by putting curly brackets here,
or curly braces here, and putting some data inside that, Dart automatically understand,
okay, this is a set of some stuff in here, and this stuff for now just looks like a string.
So if I say foo bar as, Dart says, okay, this is fine. But if I go in here and I say foo again,
you can see I automatically get an error message saying two elements in a constant set literal
cannot be equal, because it understands that this foo has already repeated there.
Okay. So let's remove foo from here, and let's do an experiment. Let's change these names to var
so that we can actually change its contents. Then go to the next line and say names, if I can
spell, and say add, and then say foo again. And then say names, add var, and then set add vas,
or sorry, names, add vas. And then we'll say print names. Okay. And I'm going to clear the logs with
this button right here, and then I'm going to press command S. And you can see that the set
is still foo bar vas. Nothing changed really there. That is one of the greatest properties of
lists, of sets in Dart, and in pretty much every other programming language that supports sets,
and that's sets ensure always that their data is not duplicated. And this is, I mean, there's
lots of magic happening in the background that I haven't really talked about. I mean, for instance,
the question that you may ask, how does Dart know foo is the same as foo? Does it compare them?
Yes, it kind of does, actually. It's internally doing a comparison between these things, but we
never told it how that comparison should work. And that is because, if you remember from operators,
when we talked about it, the string, now we haven't talked about classes. Well, I'm just going to say
strings in Dart already know how they should be compared with other strings. So, they kind of
have this logic of hash codes and comparison operators that they know exactly like, okay,
given this string, am I the same as that? Sorry, given what I am and this new thing that you're
providing me, I'm foo and you're saying foo, am I the same as foo? And then it says yes or no.
So, that is what sets are doing internally, but we don't actually see that. So, just know for now
that sets in Dart allow you to create unique list of things, okay? And then you may also be a little
bit tempted to go and say, okay, I have things here. Let's say const things is equal to foo and
then you say one. And this will also work. And that is because Dart has the concept of object
as well. You can see, you'll see things and it'll say, oh, now it's a set of object.
We haven't talked about objects yet. And if I look at my notes, I can see that we're going to
talk about objects in chapter six and we're right now in chapter four. So, we haven't really
gotten to that point to talk about objects. And I don't want to really scare you about objects
and what they actually are, but just know that there is a hierarchy of data types. So, you have
object and then you have data types that kind of derive their functionality from objects. So,
here sits object and then here sits string, integer, double, et cetera. And then you have
sets and blah, blah, blah. Now, when you were here, when you were first here and you said,
I have foo, bar, baz, all strings, then Dart was like, okay, this is a set of strings.
But then you said, oh, I have a string and I have an integer, which is a number.
Now, Dart was like, oops, I have, I can't, I mean, I don't really, I can't say this is a list of
strings and integers. That's not possible in Dart. So, it says I'm going to take the common
denominator type that sits above them as their parent to specify what these things are. Okay.
And that is kind of like the same thing that we do in real life in that if I give you, for instance,
two candies, like a Twix bar, then you would say, this is a Twix bar. That's one thing.
If I give you 10 Twix bars, then you will say a lot of Twix bars or 10 Twix bars. If I just give
you a bunch of Twix bars, you'll be like, oh, that's a bunch of Twix bars. But if I go and
like blend like lots of Twix bars, Mars bars, whatever, all the sweets into a bag and I give
you that bag, what do you call it? You don't say, oh, this is a bag of Twix and Snickers and this is
and Mars bar. No, you would probably just say candy. It's a bag of candies. And that's what
Dart is doing here. Saying, oh, you threw a lot of stuff in here. I can't comprehend it. This is
a set of objects. So we do that in real life. And that's what Dart is doing here. So just
when you see object, just know that, oh, Dart doesn't really know what this is anymore.
Or it kind of knows what it is. It's just a bunch of stuff. So that's what object in this case means.
So that was a weird comparison, maybe. But I hope you get what I mean.
And if you see me looking here, it's just because I'm looking at my notes to ensure that I've
explained the things that I've set out to explain. So talked a little bit about hash codes and sets.
We don't have to go into details about that. So now let's go and talk a little bit about maps.
Now let's go and talk a little bit about maps. And maps are one of my favorite data structures
in any programming language that supports them. Pretty much almost all modern programming languages
support maps. So a map is a data structure. As you can see here, maps are used to hold
key value pairs of information. And what that means is,
let's say that you want to explain a person using their different properties.
Then you would say age, their gender, their hair color, their height, whatever, name, all of that.
So these are kind of like your keys. So you would explain the properties of that person
using those keys. And all those keys have their values. So if you say height, then you would say
like 180. And if you say weight, then you would say like 70 kilograms. So these are key values.
The keys are the properties of that person and the values are the values of those properties.
And the way to create a map is very similar. So it's very similar to a set with curly brackets.
You say person, and then you say equal to. Actually, this is just a name. You don't have
to say person, but yeah. Or you can just say const. So person, and then you open curly brackets,
and then you would do your keys here. And I would say the key of age, for instance, I'll say 20.
And then you say colon. Is it colon? Yeah, it's a colon. And then you end the whole set
with a semicolon. So I just created a basically here, I created a map whose keys are string
and values are integers. Now let's see if Dart understands that. You see, it's a map of string
as keys and int as values. But now, as you saw before, the analogy of candies, now if I say,
okay, I have another key, and it says name, and I say, oh, the name is foo. Now Dart's going to be
like, ooh, what is this person? Oh, it's a map of string as keys and object as the value. Because
it just looks at the common denominator of the string, which is foo, and 20, which is an integer.
It says, oh, I don't know. I can't create a map whose keys are string and its values are both
string and integer. So I'm just going to go to their parent and be like, oh, the parent of both
string and integer is object. So your values are of type object. So a bunch of candies, basically.
Okay. That's how you create a map in Dart. And the other property of a map is, for instance,
you would say, if you go and create an age again here, you see it says two keys and a constant map
literal cannot be equal. So it's doing some checks here, making sure that the keys are actually
unique. So keys inside a map need to be unique. All right? However, if you go and change this
and say var person, and then you later go and say person name is equal to foo, just like that,
and then you print the entire person. So I'm just going to say print before and print after.
Okay? And you can see here, it said first time age key is 20, it has a value of 20, and the name key
has a value of foo with a capital F. Then the second time around on the print statement on line 15,
then when we print the person, it has the key of age with a value of 20, because we didn't modify
that, and a key of name as it was before with the value of foo with like six, I think,
capital O's. So this is how you would modify a map. You would specify the key, and then you would
say equal to, which is an operator, and then you would say the new value. All right? However,
if you added a new key here, for instance, last name, and you say Baz, and that will just kind
of like get appended to the map. So age the same, name the same, now you have a new key
whose value is Baz. All right? And that is kind of like the basics of
maps. So there are lots of things you can do with maps, and I really encourage you,
just like everything else that I talked about in this chapter, that you go and read some of
the documentations, because if you're following along with this course and your goal is to become
a software engineer, and if you're, for instance, a project manager or a designer, UXer, whoever you
are, I think you need to understand that software engineers do not know all the answers. You have to
go and read documentations. You have to practice, practice, practice, and put time into it. Countless,
countless hours you need to put into learning. So I mean, this course, I think, is going to be so
many hours long. The way I can, I mean, I can see the planning for all the chapters that I've put
here. There are so many chapters. I think the entirety of this course is going to go over 20
hours. So you can imagine that I can't go into details about every single thing. Otherwise,
it is just, this course is probably going to be like 200, 300 hours. It's unbelievable. So
we can't do that. So what I expect you to do now is just to open your browser and just type
dart maps documentation, something like that, dart maps. So, and you also need to know that now that
you're starting to Google things, you need to be aware of the word dart and that dart is an existing,
very popular name for just darts, darts. Okay. So sometimes depending on what you're Googling,
if a topic related to the classic darts that you throw is more popular than the topic of
the programming language, which kind of sounds the same, it may pop up first. So in this case,
if you say dart map, you may actually end up in some sort of weird website that explains to you
how you can throw darts at a map. I don't know. I'm just trying to bring it up because I actually
ended up in that situation that I searched for something related to dart. I actually ended up
in a weird website talking about darts as like a sport. So know that as well, please.
All right. Now we've talked about maps. So I'm going to take that in my notes. Now
what's coming in the next chapter, we are going to talk about a very important concept in darts
and many other programming languages such as Rust and Swift, and that is null safety or dart calls
it the sound null safety. It is a very important thing to know about in darts and it will greatly
and it will greatly help you in the future as you write your Flutter applications.
In this course, I'm going to use a lot of null. I'm going to make a lot of null references,
talk about null quite a lot throughout the course. So it is very important that we go through that
as soon as possible, and we're definitely not going to leave that out. So
that's going to be for chapter five. So keep an eye out for chapter five that is to follow. So
I hope that you enjoyed this chapter, chapter number four, where we talked about dart control
statements and collections, and I'll see you in the next chapter. Hello everyone, and welcome to
chapter number five of this Flutter course. In this chapter, we're going to talk about null safety.
In the previous chapter, chapter number four, we talked about
dart control statements and collections. And before we go on to talk about enumerations
and objects and classes, I feel it is very important to talk about null safety, which is
a concept that is available in most modern languages such as Rust and Swift. So it is
important to get this out of the way before we continue. Maybe not even get it out of the way,
but actually learn what it means and try to utilize it so that we can write better code.
So I thought to just bring up the concept of null values and why they're important to handle. Well,
you've seen so far that we have data types. A data type can be, for instance, a string,
can be an integer, and then you can put values in them. However, in programming languages,
you are also allowed to have the concept of the absence of a value. So on one hand, you have
values. So you, for instance, have a string value equal to foo bar or your name or whatever it is.
And then on the other hand, you can have the absence of that value. So you can see that,
okay, I have a container, I have a variable that can contain the values of type string,
or I have a variable that can contain any object. However, at the moment, I don't have that value.
So you will just tell Dart that this variable that I have right now can either contain a valid
value of type object or of type string or integer, or it can sometimes also during its lifetime
contain nothing. And this nothingness is the concept that is known as null.
So it's null in Dart is a keyword. It means that it's a word that you can just write in your
text editor as you're writing your code. And you say that a variable's value is equal to null.
And this tells Dart that, well, okay, this variable at the moment doesn't contain any values.
So null is not really a value, but it's actually the absence of a value. You should think of it
that way. So let's have a look at this. There's a little bit of a documentation here.
On Dart's website, Dart dev null safety. So I'm just going to click on it. You're not going to
see my screen at the moment. I'm just bringing it up in a browser, a browser window. I'm going to
bring it on the screen and increase the size a little bit and also change the sizing on the
the window as well. So you can see the contents in its entirety.
So as you can see in Dart, it's called sound null safety. And there's documentation about
what this actually means. We're going to look at what null safety actually means in Dart. And
I'm going to give you a lot of examples of what that actually practically means. And there's
documentation here in Dart's website simply because Dart, in its older versions, not in its
current versions, in its older versions, it didn't support null safety. So there was a lot of code
written manually by programmers in order to, for instance, check whether a value is absent in a
variable. And then there is, as you can see here, it says migrating an existing package or app. So
there is documentation written by the Dart team in order to help developers understand how they
can move their old code to the new code that supports null safety. However, if you're following
along with this course, it's like you're basically just following chronologically from chapter one
to all the other chapters. I don't know how many chapters we're going to have, but if you're
following along with this course, you don't have to think about migrating because the code that
we're writing in this entire course is going to be null safe, meaning that we're going to take
advantage of Dart's null safety operators and meaning that we are not going to manually check
for values being null and then doing some branches of code, whether they're null or not.
So what I mean is that if you read the documentation for sound null safety,
you don't have to worry about the migration parts. Just read the rest. Okay.
So with that out the way, I'm just going to make sure that I tick that in my notes here. That's why
I'm looking in this direction because I have all my notes here. Let's close this window and bring
up our Visual Studio Code window that we had from earlier. I'm going to put it here, and I'm just
going to ensure that it is of the correct height as well. So you're going to see the window in it
height as well. So you're going to see the window in its entirety. Okay.
So now that we talked about what null values are and that there are the absence of a value,
let's have a look at making any type nullable. And if you follow along with the course up to
this point, you should have some sort of a simulator or an emulator running, and then you
should have done command shift P or control shift P depending on your operating system,
command shift P in Mac and control shift P in Linux and Windows in order to bring up this menu.
And then you can just type Flutter, select device, and then you just select the device that you want
to run the code on. So I'm kind of assuming that you've already done that and that your code is
running. And this is something that we talked about in earlier chapters. So we're not going
to go through that again. So I have an iPhone simulator, which you cannot see on the screen,
but I have it running in a separate screen just because we don't have enough real estate. I can
bring it up to this window, but it will just take a lot of space. So I'm going to bring it up to
another monitor so you don't see it. So this code at the moment is running live. So if I press command
S, then it's going to run and just print the output for us. Okay. Now let's talk about making
any type nullable. And there is a way to do that. Let's have a look here. We talked about that null
is a keyword, and that's why you can see it is highlighted here in a different color.
So if you, for instance, say final name is foo, as you can see, it says, okay, I accept this as
name is foo. But you can't just say name like it's a null because then it doesn't understand. Is it
an object? Is it a string? Is it an integer? And if you type here name, then you see it's just
dynamic. It doesn't understand the type. And we'll talk about dynamic a little bit later.
But what you can do is to actually specify that, okay, I want a string data type that
it can contain normal names or strings as we call it, like series of characters, or it can sometimes
be null. And in that case, you have to actually specify the data type as not just string,
not just this, because you'll see, you'll get an error. And we'll actually get a suggestion. It
says, try changing the type of the variable or casting the right-hand type to string.
But we're not going to do that. That wasn't such a, it wasn't such a useful suggestion because
what you want here is to actually make Dart understand that this variable right here,
or this constant right here can sometimes contain the value of null. And the way to do that is you
put the suffix after your data type as a question mark. So this is the syntax,
which is actually using some other languages as well. It's used in Swift as well.
So this tells Dart that, well, here, if we make it actually a variable, as you can see, or sorry,
like this. So you say, I have a variable. It's a string, but sometimes it may,
the string value may be absent. And then you'll just say, okay, now name is foo.
And you can say now name is null. So this is kind of like resetting out names. So if I just say,
okay, print name. And then after foo, I say print name. Okay. So let's just
clear the console and just run this application. You can see the first time it says it's null.
And then the second time around it says it is foo. So this is how you tell Dart that you
want to have nullable data type. And you can do this with pretty much all data types. So you can
just say, okay, I have an integer of age, and that's 20. But you can see you cannot now assign
the value of null to integer because it's not nullable. But as soon as you make it nullable,
then that is accepted. And of course, you can do different operations using, for instance,
in the previous chapter, I believe, we talked about control statements if and else.
So you can say, for instance, if age is 20, and then you can execute some code,
or you can say if age is null, execute some code. So they work as you would expect. So
there is no difference really. And I mean, if you think about that nullability is just like a
suffix to a data type, you can also say, okay, pretty much any data type can be nullable. And
that's great. Like, for instance, if you have a list of string of names, you can say, okay,
I have foo and bar here. This is a list of strings. I talked about lists in chapter four.
Now, you can see here that list of strings, there are two data types here, the list itself,
and the contents that it holds. So if you want to make the list in itself nullable, then you would
put the question mark after. This means this list of strings in itself can be absent. So you say
names null, and that's accepted. However, since you're telling Dart that, okay, the names value
here can in its entirety be null, but its values are not supposed to be null. So if you then go
in here and just put null in here, then you see that you got an error. And that's because Dart
is saying that, okay, you just promised me that the list in itself, it can be absent, but as soon
as it is not absent, meaning that as soon as it is present there with some values, its values cannot
be null. And that means that this type should be telling me here that it is null. So if you want to
make an optional or nullable list of optional strings, then you would put the question mark
after the data type of string as well. So this is now, I mean, the way you should read this is,
I have a list of strings, and I call that list names. Names can sometimes be null, meaning that
it can be absent. And if it is not absent, it can contain objects of type string that themselves
can sometimes be absent, meaning that, okay, for instance, if you say foo bar null, that's accepted,
but you can also say names is null. See what I mean? So both the container, which is called names,
and the values that it contains can be optional. And the word optional is very important for you
to learn. It's kind of like an industry accepted way of talking about nulls and nullable values.
So this is optional, all right? Okay. Now we talked about that,
nullable values and optional values, all right? Basically, you can use those words interchangeably.
So if you're talking with a colleague programmer, you would say, oh, how would you describe this?
Okay, this is an optional list of optional strings. Or you could also say nullable list
of nullable strings. But optional is also a word that is typically used to
talk about nullable values, all right? Okay. We talked about making any type nullable. So
