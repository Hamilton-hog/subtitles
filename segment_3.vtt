WEBVTT

00:00.000 --> 00:07.240
So, I think that's it for functions.

00:07.240 --> 00:12.840
Now we've talked about functions, arguments, return values.

00:12.840 --> 00:20.640
We talked about variables, constants, data types, and keywords in Dart.

00:20.640 --> 00:26.320
These are such important parts of learning how to program with Dart and Flutter that

00:26.320 --> 00:28.840
I think you need to spend some time and experiment with them.

00:28.920 --> 00:30.360
Do some experimentations on your own.

00:32.360 --> 00:33.960
Don't take just the first name and last name.

00:33.960 --> 00:37.000
Just take, for instance, someone's address, someone's age,

00:38.120 --> 00:41.960
play around a little bit with different data types like integers, different numbers.

00:41.960 --> 00:45.880
Have a look at the link that I provided earlier, which was here.

00:45.880 --> 00:47.560
I'll bring it up again so you can see that.

00:48.520 --> 00:53.240
Have a look at this link and have a look at the different examples of different data types.

00:53.320 --> 01:00.120
Because in the upcoming chapters and in the rest of this course,

01:00.120 --> 01:03.480
we're going to play around with a lot of different types of data types.

01:04.520 --> 01:08.680
I think it's important that you have a look a little bit at the documentation as well.

01:10.840 --> 01:15.480
Let's leave this chapter at this point, and then in the next chapter,

01:15.480 --> 01:22.040
we're going to talk a lot more about more advanced Dart programming language features.

01:22.920 --> 01:25.880
Thank you for joining me for this chapter and see you in the next one.

01:27.000 --> 01:30.840
Hello, everyone, and welcome to chapter four of this Flutter course.

01:31.880 --> 01:36.680
In the previous chapter, chapter three, we talked about keywords, data types, constants,

01:36.680 --> 01:38.680
variables, and some basics of functions.

01:39.880 --> 01:44.840
In this chapter, we are going to, as you can see on the captions here,

01:44.840 --> 01:48.840
we're going to focus on control statements and collections.

01:49.800 --> 01:57.160
Now, I'm assuming you're following these chapters chronologically so that you're going

01:57.800 --> 02:03.800
one by one. I'm assuming then that you have your Dart project set up and that you've got

02:03.800 --> 02:11.240
some sort of a simulator or emulator running. Without further ado, let's have a look at...

02:11.800 --> 02:17.320
I'm actually going to bring up the captions here, and then I'm going to put my face at

02:17.480 --> 02:25.160
the bottom there and bring up our project that we created in the previous chapter up here.

02:26.120 --> 02:30.840
This is running at the moment. If I do a command S or a control S on Linux and Windows,

02:31.560 --> 02:34.040
then as you can see here, there is a run button.

02:35.240 --> 02:40.280
Then it's just going to do a hot reload, which in turn calls this build function,

02:40.280 --> 02:43.960
which we don't yet know really how it works because I haven't really explained it.

02:43.960 --> 02:50.520
But what we did, we just called a print function here and then our get full name function.

02:53.000 --> 02:56.520
What I'm going to do here is let's remove this code from the build,

02:57.240 --> 03:01.320
and let's remove everything that we wrote here as well. Keep the main function,

03:01.320 --> 03:06.120
as you can see here, and then keep your stateless widget, which we're going to talk about later.

03:07.400 --> 03:11.800
Instead, go and create a new function that is called void test.

03:14.760 --> 03:20.120
And then in the build function, just say test. Just like that.

03:21.880 --> 03:26.920
The purpose is that in this function, we're going to write most of the code in this chapter.

03:26.920 --> 03:29.960
We are going to basically test some code. That's the purpose of this function.

03:32.280 --> 03:40.520
Let's talk about if and else. If and else are control statements in most programming languages

03:40.520 --> 03:47.000
that allow you to branch your code based on a condition. So if we, for instance,

03:47.000 --> 03:53.640
in here create a final variable whose value cannot be changed, if you remember from the

03:53.640 --> 03:56.360
previous chapter, whose value cannot be changed after it's been assigned to,

03:57.080 --> 04:07.720
let's say final name is foo, and end it with a semicolon. Now, an if statement basically allows

04:07.720 --> 04:17.880
you to check the value or a condition to be of a certain value or to be true or false, and then it

04:17.880 --> 04:24.840
allows you to execute some code, and then you can also append an else statement to it, which gets

04:24.840 --> 04:29.960
executed if the code or if that condition is not met. I'm going to show you how that is written.

04:30.840 --> 04:38.440
The syntax for an if statement is just if, and if is a keyword. So you would say if,

04:38.440 --> 04:44.440
and then you would open and close parentheses, and then you would put curly brackets like this.

04:44.440 --> 04:48.040
That's the syntax of if. And in the parentheses, you would put your condition.

04:48.680 --> 04:55.640
So I would say in this case if name, and I would like to, for instance, check if name is foo.

04:56.600 --> 05:03.080
Now, we haven't come to operators yet. We're going to talk about operators actually soon.

05:04.280 --> 05:11.240
But this is, as you can see here, we're saying final name equal to foo. This is kind of like

05:12.040 --> 05:19.880
an assignment operation, and that is an operator. In Dart, it's called an operator. So there is

05:19.880 --> 05:23.960
also, and since this is an assignment, we don't want to actually assign anything to name. We want

05:24.280 --> 05:30.600
to check if it's of a certain value, and that is with this conditional operator. Equal, equal.

05:32.040 --> 05:37.080
And then you would just say, okay, if it's foo, then, for instance, print.

05:39.560 --> 05:46.280
Yes, this is foo. And then a semicolon to end it. However, if this condition is not met,

05:46.280 --> 05:52.680
you may want to execute another piece of code, and then you can just do else. Like that.

05:53.960 --> 06:01.160
Then you would just say, no, this is not foo. And a semicolon. So I'm just going to do command S,

06:02.200 --> 06:06.440
and you can see the value or the string, yes, this is foo printed to the screen,

06:06.440 --> 06:12.920
or to the terminal here, or to the debug console. You can have multiple statements in here. So you

06:12.920 --> 06:17.720
can have more print statements in here. You can just do anything you want basically in here.

06:18.360 --> 06:25.720
And the same goes for else. Now, there is a possibility to write if statements kind of

06:25.720 --> 06:31.080
without the curly brackets, but you don't see them that often, and I recommend that you actually

06:31.080 --> 06:36.920
always try to, as a convention, do with the curly brackets if you can. However, it is possible that

06:36.920 --> 06:43.160
inside a code base that you will work on with your colleagues, it is decided that it's okay to have

06:44.120 --> 06:49.480
if statements without curly brackets where they are very simple and one-liners, basically.

06:50.520 --> 06:55.320
So let me show you an example of that. You could just say, if name is foo,

06:57.800 --> 07:04.200
and you would just say print, yes, this is foo. And this is completely accepted as well,

07:04.200 --> 07:11.720
because it's a one-liner. But if you then say, okay, I want to have another line, print hello world,

07:13.320 --> 07:21.080
you can see it goes to the next line, meaning that this line right here will be executed no matter

07:21.080 --> 07:25.480
your condition up there. So this is completely detached from your if statement up here.

07:26.840 --> 07:30.440
I just realized that it is quite important for me to be able to show line numbers.

07:31.240 --> 07:36.120
And by default, your editor probably has line numbers enabled. I usually disable line numbers

07:36.680 --> 07:42.360
when I'm working myself, basically. But when talking about code with other people,

07:42.360 --> 07:46.200
it's quite useful to have line numbers, because I can then tell you, oh, look at line nine or

07:46.200 --> 07:56.520
look at line 10. Okay. So that's the basic of if and else. Now, you can also have if right after

07:56.520 --> 08:06.920
else. So an example of that is, for instance, to say if name is foo, and then you do some code,

08:06.920 --> 08:15.720
all right? You say print, yes, it is foo. Not food. After the curly bracket, then you would say

08:15.720 --> 08:22.840
else. And then you can then say another if, else if. All right? And then after if comes the

08:23.400 --> 08:28.760
parenthesis and a curly bracket, if you remember from the if before. It is the exact same syntax

08:28.760 --> 08:34.760
as it is here. So there's pretty much no difference. You can see if and then if.

08:35.720 --> 08:41.160
And then you put your condition in here. You would just say if name. And then you may just want to

08:41.160 --> 08:48.760
say is not. And that's another operator. It's basically is a not operator. So it's checking

08:48.760 --> 08:54.120
to make sure that this name is not of the value that you provide to the right-hand side.

08:55.000 --> 09:05.640
And then you can say bar. And print. This value is not bar. Else. And then you can wrap it up,

09:05.640 --> 09:14.200
and you can say print. I don't know what this is. Now, I'm so glad I actually accidentally ran into

09:14.200 --> 09:19.240
this issue. As you can see now, the editor is kind of going crazy, and Dart's not understanding

09:19.240 --> 09:24.840
and Dart's not understanding what this statement is. And as we talked about it previously,

09:26.120 --> 09:32.520
strings in Dart are preferred to have to be kind of like created with single codes. However,

09:32.520 --> 09:37.720
if your string in itself contains a single code, for instance, in this case, the word don't

09:39.080 --> 09:45.720
contains a single code, then Dart kind of gets confused. Like, okay, does the string end here?

09:45.720 --> 09:51.720
You can see up until this point, it's green. So it's thinking, oh, the string ends here,

09:51.720 --> 09:58.200
but what is all of this then? That follows. If you have that problem, there are two ways of

09:58.200 --> 10:08.680
fixing that. Either you escape your single code, and that is a software kind of development lingo.

10:08.680 --> 10:18.520
Escape. If you hear that, it pretty much just means that you are kind of wrapping it in a way

10:19.560 --> 10:24.360
that Dart understands that you don't mean it literally. You don't mean that I want to

10:24.360 --> 10:29.720
end my string here, except that this needs to be escaped and put in the string as its own value.

10:29.720 --> 10:34.920
Basically, it's kind of difficult to explain, but I think you know what I mean. So that's one way

10:34.920 --> 10:40.200
of doing it. It's a little bit dirty. So in case you run into this issue, it's best to actually

10:40.200 --> 10:45.640
wrap your entire string in double quotes. And this way, then Dart understands that whatever

10:45.640 --> 10:51.800
comes in here is okay. Like a single code is completely okay. Unless you actually want to have

10:52.440 --> 10:59.480
a double quotes in your string that is enclosed with double quotes again. So you'll see if I

10:59.480 --> 11:04.680
put a double quote here, then Dart goes crazy. So you can escape it with a backslash like that.

11:05.720 --> 11:10.440
So if you have single quotes and double quotes in your string, then you will have to kind of

11:10.440 --> 11:15.240
pick a convention. Either you enclose the entire string in single quotes and escape your single

11:15.240 --> 11:21.560
quotes inside that string and let the double quotes live, or you enclose your entire string

11:21.560 --> 11:30.360
in double quotes and then you will escape your double quotes in the string. I hope that makes

11:30.360 --> 11:40.680
sense. So that is if and else in a nutshell. But before I move on, I kind of want to explain

11:40.680 --> 11:45.800
an important concept here in that when Dart executes this code, it kind of goes by line by

11:45.800 --> 11:51.320
line. So it starts with line seven, the execution of this test function. Then it comes here and

11:51.320 --> 11:57.560
it says, okay, name is foo, all right. And it's actually saying that we prefer const. So let me

11:57.560 --> 12:07.080
change that to const. And it says, okay, if name is foo, all right, then it comes over here. But

12:07.080 --> 12:15.000
let's just change that to foo with triple o. Actually, yeah, no, let's not do that. Let's

12:15.000 --> 12:22.440
keep it as foo. So it says if name is foo. Then it says, yeah, that's true. And then it goes here.

12:22.440 --> 12:31.720
However, as you can see, the line number 11 also says if name is not bar, then it should execute

12:31.720 --> 12:39.960
this as well. And you can see that foo is not bar. So this condition is also true. However,

12:39.960 --> 12:47.080
this will never be executed. And that is because when Dart goes inside these curly brackets,

12:47.080 --> 12:51.800
then it says, okay, I did what I had to do. I did my print statement. The rest I ignore.

12:52.680 --> 13:00.600
So an if statement is kind of like, it puts a stop. When it falls into one of these if statements,

13:00.600 --> 13:07.000
it kind of says, okay, I did my job in this entire if else block, then I will execute the code after

13:07.000 --> 13:12.680
that. So if I clear the console here and press command S, you can see it only says yes, it is foo.

13:12.680 --> 13:21.400
It doesn't come here. However, if you change this condition so that the Dart compiler or

13:22.040 --> 13:26.760
basically the execution of the program doesn't fall into line number 10, it will eventually fall

13:26.760 --> 13:32.600
to line number 12. So you can see it says this value is not bar. So when you're writing your if

13:32.600 --> 13:36.840
statement and else statements, just be careful with that. Just know that it's kind of like as

13:36.840 --> 13:42.040
soon as the code jumps into one of those branches, it doesn't go to the rest of the branches and

13:42.040 --> 13:56.520
checks them basically. All right. Okay. That was for if and else. Now let me check that in my notes

13:56.520 --> 14:07.640
that we've talked about that. What we need to do now is to talk about operators. Operators,

14:07.720 --> 14:14.600
there are three different types of operators. There are prefix operators, infix operators,

14:14.600 --> 14:27.320
and suffix operators. And I will explain them to you how they work. I think to explain operators

14:27.320 --> 14:32.120
probably is best that we talk about numbers. So let's go in this test function and delete

14:32.280 --> 14:37.480
in this test function and delete everything that we've written here. And let me just say final

14:38.840 --> 14:47.160
age is 20. All right. So now we created a variable whose value cannot be changed after

14:47.160 --> 14:52.440
it's been assigned to because we create as a final a variable whose value is 20. All right.

14:52.440 --> 14:58.440
Now if you want to calculate half of this value, how would you do that? Well, there is an operator

14:58.440 --> 15:05.800
for that and that is a division operator. So you would just say, for instance, final half of age.

15:05.800 --> 15:10.600
As you can see, we're using camel case as I explained in the previous chapter. An easy way

15:10.600 --> 15:19.400
to do camel case is to say half of age is writing in English, change the first letter of like this

15:19.400 --> 15:23.880
here. Change the first letter of all the words except for the first word to uppercase and then

15:23.880 --> 15:30.200
remove all the spaces. That's camel case. So half of age is age. And then there is a great

15:30.200 --> 15:37.480
operator in Dart called a division operator. And then you would say two. All right. And then

15:37.480 --> 15:46.200
you could just say print half of age. So command S. And that says 10. All right. So that's the

15:46.200 --> 15:52.440
division operator. And then you will have, let's say, final double the age.

15:54.840 --> 16:01.480
And then we will say age multiplied by two. It's kind of like a star. That is an operator. And you

16:01.480 --> 16:10.600
can see these both operators, this one, the division and the multiplication, multiplication,

16:10.680 --> 16:17.560
it's a bit difficult to say, operators are infix operators. And an infix operator is an operator

16:17.560 --> 16:21.880
that has two parameters, one to its right and one to its left. I don't know how you can actually,

16:22.600 --> 16:29.080
yeah, one to each side. I don't know if my video is mirrored. So if my right hand is actually

16:29.080 --> 16:34.920
right hand on your side as well. So I don't know. Yes, it is probably. So

16:34.920 --> 16:44.920
these are infix operators when they have two values, one to each side. However, they're also

16:47.000 --> 16:55.080
prefix operators. And an example of that is, for instance, if I said final, age minus one.

16:56.440 --> 17:04.440
Actually, we change this to var. I'll explain soon why. And if we said minus, minus age,

17:05.640 --> 17:11.880
now, this is an example of a prefix operator. And a prefix operator is an operator that

17:12.440 --> 17:19.320
it comes before whatever it has to do its work on. And in this case, this minus,

17:19.320 --> 17:23.160
minus operator, what it does is that it takes the value that comes after it,

17:24.440 --> 17:32.600
it decreases that value by one, and then it returns its result back to the left-hand side.

17:32.600 --> 17:38.760
So in this case, the interpreter comes here and says, okay, you want to calculate something.

17:38.760 --> 17:45.800
Okay. It's equal to, oh, a prefix operator that takes a variable here. And it says, okay,

17:45.800 --> 17:55.000
what is age? It's 20. Minus one is 19. Puts it in here. And it also puts that 19 in an age. So

17:55.640 --> 18:01.640
I think so, at least. So if we say print age and print age minus one, now both should kind of be

18:01.640 --> 18:09.160
19. And you can see it says twice. You see two, 19. So that kind of means it's twice. So Flutter

18:09.160 --> 18:14.440
has this great ability not to duplicate, basically, log statements or print statements.

18:16.360 --> 18:22.920
So we have, I mean, there are some really great operators in Dart. And that is the plus operator.

18:24.120 --> 18:30.040
And then you have the minus division multiplication. And then you have the logical

18:30.600 --> 18:34.920
operators to check if a value from the left is equal to the value to the right. So

18:35.720 --> 18:41.880
these are the basics of the operators in Dart. So you don't have to know so much more about these

18:41.880 --> 18:50.120
for now. I would say you can get really far with these. And a lot of these operators actually work

18:50.120 --> 18:56.760
not only on numbers, but also on strings. And for instance, this is one of the cool features of Dart,

18:56.760 --> 19:02.040
which I absolutely love. I think it was just such a great idea for them to implement this.

19:04.920 --> 19:09.320
If you're not coming from a software development background, you may not know this. But if you're

19:09.320 --> 19:12.680
coming, for instance, from a design background, also, you would notice that sometimes when you're

19:12.680 --> 19:19.080
creating designs or any screen and you want to show that design to someone, like a product owner,

19:19.960 --> 19:25.080
you want to actually populate the text inside your design with some lorem ipsum.

19:25.880 --> 19:31.000
And lorem ipsum basically has a huge history of where it comes from. But it's usually some sort

19:31.000 --> 19:37.160
of a dummy text that you want to place inside your design so that you can display and show it to

19:37.160 --> 19:42.760
someone. And a lot of developers, like in many languages, when they want to display some text

19:42.760 --> 19:46.760
and they don't know what to say, like, we're just testing stuff. I just want to display some text.

19:46.760 --> 19:53.400
They go and grab lorem ipsum and then put it in their code. But Dart has gone to the next step

19:53.400 --> 19:57.800
and said, OK, we don't need that. So what you can do, you can say, for instance, name is foo.

19:59.240 --> 20:08.040
That's a string name. But you can say name times 20 is name times 20. You can literally say multiply

20:08.040 --> 20:16.200
a string by 20. And what that does is that it says foo 20 times. So if I say print name times 20,

20:17.000 --> 20:22.920
you can see it says foo 20 times. So it's a great feature. You can say foo, bar,

20:22.920 --> 20:29.400
baz, and then just say times 100. And yeah, it just, that's it,

20:29.400 --> 20:39.960
copies it for you 100 times in names time 100, for instance. So that is a, that is

20:40.120 --> 20:47.880
shortly said, that is the basics of operators in Dart. OK, I'm going to delete that code.

20:49.560 --> 20:59.160
I'm going to mark in my notes that we've talked about that. Now, I'm just going to quickly also

21:00.120 --> 21:11.560
mention that we can also create custom operators, to be honest with you. And I don't think it is

21:11.560 --> 21:18.760
completely all right right now to talk about custom operators. I think it's kind of like a topic to

21:18.760 --> 21:23.640
talk about later. So I actually just moved it in my notes that we don't need to talk about it right

21:23.720 --> 21:29.640
now because we have to know a little bit about classes and objects so that we can,

21:29.640 --> 21:33.640
after we've created our own class, then we can create custom operators as well. So

21:34.680 --> 21:38.280
I don't think it's completely appropriate to talk about right now. But just know that

21:38.280 --> 21:42.680
in the future, you can also create your own operators and then like, or you can also

21:42.680 --> 21:47.400
override like different operators and how they work with different objects. So it is really fun.

21:48.200 --> 21:53.800
But that's that. Let's just leave operators to that for now.

21:55.800 --> 21:59.160
Now, the next topic that I wanted to talk about is lists.

22:01.400 --> 22:13.560
And lists in Dart is a series of things that are similar to each other and they are placed inside

22:13.560 --> 22:18.360
a list, as you would have, for instance, on a piece of paper and you could write your shopping

22:18.360 --> 22:27.320
list or like a Christmas shopping list or whatever, and it's numbered. So these are called lists in

22:27.320 --> 22:38.280
Dart. So for instance, if you say foo, and then bar, and then baz. As you can see, Dart doesn't

22:38.840 --> 22:42.280
like this syntax at the moment. It says, okay, what are these? Like, what is this

22:44.280 --> 22:50.920
comma here? The way to tell Dart that this is a list of things that are like in place one,

22:50.920 --> 22:57.720
two, three is by placing them inside square brackets and then a semicolon, of course.

22:58.120 --> 23:07.080
Now, as I've talked about it before, just now, actually, lists have indexes in that they all

23:07.080 --> 23:12.920
have their own placement inside the list. All these objects, as we call them, they have their

23:12.920 --> 23:20.200
placements inside the list. And you may think that object number one is foo and then object number

23:20.200 --> 23:27.720
two is bar and number three is baz. And that's correct. But indexes in, I mean, all the programming

23:27.720 --> 23:37.400
languages that I've worked with, C++, C, Rust, Dart, Swift, JavaScript, they pretty much all

23:37.400 --> 23:44.040
start at the index of zero. And that is so important to understand because like the placement

23:44.040 --> 23:54.200
of this object called foo inside this list is not one. Its index is zero. And that is why lists are

23:54.200 --> 24:01.000
called zero-based and their indexes are called zero-based indexes. So you've got to be careful

24:01.000 --> 24:07.480
with that. And we're going to talk about indexes soon, actually. So let's just say final names is

24:07.480 --> 24:14.840
that. Now, if I want to extract foo from here, I'm just going to say final foo is names at the

24:14.840 --> 24:20.200
index of zero, right? And I'm just going to print it. I'm just going to say print foo. And you'll

24:20.200 --> 24:26.440
see foo printed here. Now, if I say I want to get baz, then I'm going to say print, sorry,

24:27.320 --> 24:33.880
index of three. And you'll see, oh, sorry, index of three. And you'll see, oh, sorry,

24:34.040 --> 24:40.200
index of two, because it's the third item. But since indexes are zero-based, then it's index of

24:40.200 --> 24:46.840
two. I made the mistake myself. So command S and you'll get baz. And I actually want to go back to

24:46.840 --> 24:51.720
this three and then command S. So you can see what happened here. You'll see you'll get something

24:51.720 --> 24:59.640
called a range error, which is an exception, an exception in Dart and many other programming

24:59.640 --> 25:05.160
languages is when things go wrong so that the language doesn't really know anymore what you

25:05.160 --> 25:11.400
mean. And in this case, you can see this through an exception at the language level or at the

25:11.400 --> 25:17.560
library's level where it says, there are no four items in this array or in this list, because the

25:17.560 --> 25:25.560
index of three indicates four items. Item number one in the list has the index of zero, and then

25:25.720 --> 25:36.200
items. Item number two has the index of one. Item number three has the index of two. And item

25:36.200 --> 25:43.800
number four has the index of three. And there are only three objects in this array or in this list.

25:43.800 --> 25:52.280
So index zero, one, two. So that's it. And index of number three is non-existent. And that is why

25:52.280 --> 26:01.880
we're getting this invalid value, not in inclusive range zero to two. So that's how you access items

26:01.880 --> 26:08.040
inside a list. And this is how you actually create a list, okay? So you say list of items,

26:08.040 --> 26:16.440
which is full bar baz. So you can also, there are some convenient properties on lists that you can,

26:16.440 --> 26:23.720
for instance, say, final length. So if you want to know how many items are in this list, you can

26:23.720 --> 26:32.520
also say names, dot, and then you would say length. And we're going to talk a little bit about dot now

26:32.520 --> 26:39.960
as well, because I think it's so important to understand what dot is. Dot in Dart and in many

26:39.960 --> 26:46.440
other programming languages is a way to drill in to something to extract something else from it.

26:46.440 --> 26:57.240
And in this case, names is a list. And all lists in Dart have something called properties. Length

26:57.240 --> 27:07.080
is a property of the list data type in Dart. And that means every list in Dart has a property

27:07.080 --> 27:12.760
called length that is automatically calculated for you. You don't have to do anything. As you

27:12.760 --> 27:20.280
enter values in this list, this length is going to then return the right value to you. So I'm just

27:20.280 --> 27:24.680
going to talk about that a little bit more. So I'm just going to say print names length. It's going

27:24.680 --> 27:31.400
to say, you'll see here, let me scroll a little bit, it'll say three, three items in this array.

27:32.360 --> 27:36.360
I'm going to change the names list to var so that we can actually

27:39.000 --> 27:45.880
change its contents and mutate it. I just want to add a new name to this names. And I will just say

27:45.880 --> 27:52.280
add. It's a function, as you can see, because it has parentheses right after it. And I will say

27:54.040 --> 28:00.600
my name. And then semicolon to end the statement. Now, if I say print names length right after this

28:00.600 --> 28:07.800
statement, you guessed it. Oh, I can see, actually, you may not see all the print statements

28:07.800 --> 28:13.880
because this text is right there. So let me resize my Visual Studio code a little bit so you can see

28:13.880 --> 28:21.880
things a little bit better. Sorry about that. So now we have names length here. And you can see

28:21.880 --> 28:33.160
the second time around it said four. So when you say dot after the name of a variable,

28:33.160 --> 28:37.400
and that means it can be a constant, a variable, or a final variable, after you put dot

28:38.200 --> 28:44.280
after its name, you're accessing different properties or different functions inside that

28:44.280 --> 28:50.120
thing. So it's kind of like an accessor. It allows you to drill down inside an object and grab things

28:50.120 --> 28:59.320
out of it, or maybe make that object do something for you. So I think that's good enough, to be

28:59.320 --> 29:03.960
honest with you, about lists. I don't want to go too much into details and scare people about

29:04.680 --> 29:11.800
all the different things you can do with lists. But there is great documentation on Dart's own

29:11.800 --> 29:16.360
website. All you have to do is just to Google or duck, duck, go, or whatever you want to use, bing

29:17.080 --> 29:23.960
your way through and just search for dart arrays documentation, or just dart arrays, and then you

29:23.960 --> 29:29.160
will find lots of information about it. Or sorry, dart lists, because in dart they're actually

29:29.160 --> 29:34.120
called lists. In some other programming languages they are called arrays, but those names can be

29:34.120 --> 29:38.680
used interchangeably, to be honest with you. Lists and arrays are kind of like almost the same thing.

29:38.680 --> 29:50.440
So all right, that was lists in dart. I'm going to take it in my notes so that we know we've talked

29:50.440 --> 29:59.480
about it. The next topic that I want to talk about in this video are things called sets.

30:02.040 --> 30:08.520
All right, and as you can see in the caption I've written here is a list of unique things.

30:08.760 --> 30:18.280
Whereas lists were lists of homogeneous things, sets are lists of unique things. So

30:20.920 --> 30:25.000
I think the best way actually to explain sets is just to jump right into it.

30:25.000 --> 30:32.440
So the syntax for set is with a curly bracket. Actually, I think it is.

30:32.440 --> 30:39.640
Yeah, I think so. So let's say final names, and I'm just going to say curly bracket foo,

30:40.760 --> 30:47.880
and then end that. Okay, just like that. Now if I type names here, you will see that the suggestion

30:47.880 --> 30:54.040
provided here, or the information provided by Visual Studio Code says names is a set of string.

30:54.840 --> 31:00.040
We talked about this in the previous chapter, that when I say final names,

31:00.040 --> 31:07.400
or final something, name, for instance, is foo, I'm kind of telling Dart to create a variable

31:08.680 --> 31:14.680
whose reference name is name, and its value is foo, and Dart automatically understand that the

31:14.680 --> 31:22.840
data type of this value is string, because its data is string. So you don't have to say final string

31:22.840 --> 31:30.280
is string. Although you could do that, but let's change this to const as well.

31:32.680 --> 31:37.160
You don't have to actually say this is a string, because Dart understands it automatically.

31:37.160 --> 31:41.560
So you just remove the data type if that's what you want to do, which is what I actually prefer

31:41.560 --> 31:47.640
to do instead of being too verbose, unless you have a really good reason to provide the data type.

31:47.640 --> 31:57.560
Anyways, let's go back to sets. So we were here. And in the same way that we created a string,

31:57.560 --> 32:03.400
and then Dart automatically understood the data type, by putting curly brackets here,

32:03.400 --> 32:07.800
or curly braces here, and putting some data inside that, Dart automatically understand,

32:07.800 --> 32:12.840
okay, this is a set of some stuff in here, and this stuff for now just looks like a string.

32:12.840 --> 32:24.440
So if I say foo bar as, Dart says, okay, this is fine. But if I go in here and I say foo again,

32:24.440 --> 32:30.280
you can see I automatically get an error message saying two elements in a constant set literal

32:30.280 --> 32:35.320
cannot be equal, because it understands that this foo has already repeated there.

32:35.880 --> 32:42.120
Okay. So let's remove foo from here, and let's do an experiment. Let's change these names to var

32:42.120 --> 32:49.640
so that we can actually change its contents. Then go to the next line and say names, if I can

32:49.640 --> 32:59.160
spell, and say add, and then say foo again. And then say names, add var, and then set add vas,

32:59.560 --> 33:07.800
or sorry, names, add vas. And then we'll say print names. Okay. And I'm going to clear the logs with

33:07.800 --> 33:15.000
this button right here, and then I'm going to press command S. And you can see that the set

33:15.000 --> 33:24.440
is still foo bar vas. Nothing changed really there. That is one of the greatest properties of

33:25.080 --> 33:33.080
lists, of sets in Dart, and in pretty much every other programming language that supports sets,

33:33.080 --> 33:43.080
and that's sets ensure always that their data is not duplicated. And this is, I mean, there's

33:43.080 --> 33:48.360
lots of magic happening in the background that I haven't really talked about. I mean, for instance,

33:49.240 --> 33:55.720
the question that you may ask, how does Dart know foo is the same as foo? Does it compare them?

33:55.720 --> 34:03.720
Yes, it kind of does, actually. It's internally doing a comparison between these things, but we

34:03.720 --> 34:10.520
never told it how that comparison should work. And that is because, if you remember from operators,

34:10.520 --> 34:17.320
when we talked about it, the string, now we haven't talked about classes. Well, I'm just going to say

34:17.320 --> 34:29.240
strings in Dart already know how they should be compared with other strings. So, they kind of

34:29.240 --> 34:34.120
have this logic of hash codes and comparison operators that they know exactly like, okay,

34:35.080 --> 34:42.680
given this string, am I the same as that? Sorry, given what I am and this new thing that you're

34:42.680 --> 34:47.080
providing me, I'm foo and you're saying foo, am I the same as foo? And then it says yes or no.

34:47.080 --> 34:56.920
So, that is what sets are doing internally, but we don't actually see that. So, just know for now

34:56.920 --> 35:05.400
that sets in Dart allow you to create unique list of things, okay? And then you may also be a little

35:05.400 --> 35:14.600
bit tempted to go and say, okay, I have things here. Let's say const things is equal to foo and

35:14.680 --> 35:22.680
then you say one. And this will also work. And that is because Dart has the concept of object

35:22.680 --> 35:26.920
as well. You can see, you'll see things and it'll say, oh, now it's a set of object.

35:28.440 --> 35:34.440
We haven't talked about objects yet. And if I look at my notes, I can see that we're going to

35:34.440 --> 35:40.600
talk about objects in chapter six and we're right now in chapter four. So, we haven't really

35:40.600 --> 35:47.160
gotten to that point to talk about objects. And I don't want to really scare you about objects

35:47.160 --> 35:55.080
and what they actually are, but just know that there is a hierarchy of data types. So, you have

35:55.080 --> 36:02.440
object and then you have data types that kind of derive their functionality from objects. So,

36:03.000 --> 36:09.000
here sits object and then here sits string, integer, double, et cetera. And then you have

36:09.000 --> 36:13.880
sets and blah, blah, blah. Now, when you were here, when you were first here and you said,

36:13.880 --> 36:20.120
I have foo, bar, baz, all strings, then Dart was like, okay, this is a set of strings.

36:20.760 --> 36:25.160
But then you said, oh, I have a string and I have an integer, which is a number.

36:26.120 --> 36:31.480
Now, Dart was like, oops, I have, I can't, I mean, I don't really, I can't say this is a list of

36:31.480 --> 36:35.880
strings and integers. That's not possible in Dart. So, it says I'm going to take the common

36:35.880 --> 36:43.160
denominator type that sits above them as their parent to specify what these things are. Okay.

36:43.160 --> 36:48.840
And that is kind of like the same thing that we do in real life in that if I give you, for instance,

36:51.400 --> 36:57.960
two candies, like a Twix bar, then you would say, this is a Twix bar. That's one thing.

36:58.680 --> 37:04.760
If I give you 10 Twix bars, then you will say a lot of Twix bars or 10 Twix bars. If I just give

37:04.760 --> 37:10.280
you a bunch of Twix bars, you'll be like, oh, that's a bunch of Twix bars. But if I go and

37:11.560 --> 37:19.560
like blend like lots of Twix bars, Mars bars, whatever, all the sweets into a bag and I give

37:19.560 --> 37:25.800
you that bag, what do you call it? You don't say, oh, this is a bag of Twix and Snickers and this is

37:26.600 --> 37:32.600
and Mars bar. No, you would probably just say candy. It's a bag of candies. And that's what

37:32.600 --> 37:38.600
Dart is doing here. Saying, oh, you threw a lot of stuff in here. I can't comprehend it. This is

37:38.600 --> 37:45.640
a set of objects. So we do that in real life. And that's what Dart is doing here. So just

37:45.640 --> 37:49.720
when you see object, just know that, oh, Dart doesn't really know what this is anymore.

37:50.680 --> 37:58.120
Or it kind of knows what it is. It's just a bunch of stuff. So that's what object in this case means.

37:58.120 --> 38:03.160
So that was a weird comparison, maybe. But I hope you get what I mean.

38:05.080 --> 38:08.520
And if you see me looking here, it's just because I'm looking at my notes to ensure that I've

38:08.520 --> 38:16.040
explained the things that I've set out to explain. So talked a little bit about hash codes and sets.

38:16.040 --> 38:23.240
We don't have to go into details about that. So now let's go and talk a little bit about maps.

38:23.240 --> 38:34.120
Now let's go and talk a little bit about maps. And maps are one of my favorite data structures

38:34.120 --> 38:38.760
in any programming language that supports them. Pretty much almost all modern programming languages

38:38.760 --> 38:47.720
support maps. So a map is a data structure. As you can see here, maps are used to hold

38:47.720 --> 38:50.280
key value pairs of information. And what that means is,

38:53.160 --> 38:58.680
let's say that you want to explain a person using their different properties.

39:00.520 --> 39:12.520
Then you would say age, their gender, their hair color, their height, whatever, name, all of that.

39:12.520 --> 39:21.240
So these are kind of like your keys. So you would explain the properties of that person

39:21.240 --> 39:26.760
using those keys. And all those keys have their values. So if you say height, then you would say

39:26.760 --> 39:36.360
like 180. And if you say weight, then you would say like 70 kilograms. So these are key values.

39:36.360 --> 39:41.720
The keys are the properties of that person and the values are the values of those properties.

39:42.680 --> 39:49.560
And the way to create a map is very similar. So it's very similar to a set with curly brackets.

39:50.760 --> 39:56.360
You say person, and then you say equal to. Actually, this is just a name. You don't have

39:56.360 --> 40:01.560
to say person, but yeah. Or you can just say const. So person, and then you open curly brackets,

40:01.560 --> 40:06.760
and then you would do your keys here. And I would say the key of age, for instance, I'll say 20.

40:07.720 --> 40:14.360
And then you say colon. Is it colon? Yeah, it's a colon. And then you end the whole set

40:14.360 --> 40:25.640
with a semicolon. So I just created a basically here, I created a map whose keys are string

40:25.640 --> 40:32.360
and values are integers. Now let's see if Dart understands that. You see, it's a map of string

40:32.360 --> 40:39.400
as keys and int as values. But now, as you saw before, the analogy of candies, now if I say,

40:39.400 --> 40:48.280
okay, I have another key, and it says name, and I say, oh, the name is foo. Now Dart's going to be

40:48.280 --> 40:56.200
like, ooh, what is this person? Oh, it's a map of string as keys and object as the value. Because

40:56.200 --> 41:02.520
it just looks at the common denominator of the string, which is foo, and 20, which is an integer.

41:02.520 --> 41:08.360
It says, oh, I don't know. I can't create a map whose keys are string and its values are both

41:08.360 --> 41:13.080
string and integer. So I'm just going to go to their parent and be like, oh, the parent of both

41:13.080 --> 41:20.120
string and integer is object. So your values are of type object. So a bunch of candies, basically.

41:20.120 --> 41:30.920
Okay. That's how you create a map in Dart. And the other property of a map is, for instance,

41:30.920 --> 41:41.080
you would say, if you go and create an age again here, you see it says two keys and a constant map

41:41.080 --> 41:46.120
literal cannot be equal. So it's doing some checks here, making sure that the keys are actually

41:46.120 --> 41:53.880
unique. So keys inside a map need to be unique. All right? However, if you go and change this

41:53.880 --> 42:03.640
and say var person, and then you later go and say person name is equal to foo, just like that,

42:04.600 --> 42:10.920
and then you print the entire person. So I'm just going to say print before and print after.

42:11.240 --> 42:19.480
Okay? And you can see here, it said first time age key is 20, it has a value of 20, and the name key

42:19.480 --> 42:25.480
has a value of foo with a capital F. Then the second time around on the print statement on line 15,

42:26.360 --> 42:33.880
then when we print the person, it has the key of age with a value of 20, because we didn't modify

42:33.880 --> 42:39.240
that, and a key of name as it was before with the value of foo with like six, I think,

42:40.280 --> 42:47.800
capital O's. So this is how you would modify a map. You would specify the key, and then you would

42:47.800 --> 42:52.840
say equal to, which is an operator, and then you would say the new value. All right? However,

42:52.840 --> 43:01.160
if you added a new key here, for instance, last name, and you say Baz, and that will just kind

43:01.160 --> 43:08.680
of like get appended to the map. So age the same, name the same, now you have a new key

43:08.680 --> 43:16.040
whose value is Baz. All right? And that is kind of like the basics of

43:17.880 --> 43:23.560
maps. So there are lots of things you can do with maps, and I really encourage you,

43:23.560 --> 43:27.000
just like everything else that I talked about in this chapter, that you go and read some of

43:27.000 --> 43:32.440
the documentations, because if you're following along with this course and your goal is to become

43:32.440 --> 43:37.560
a software engineer, and if you're, for instance, a project manager or a designer, UXer, whoever you

43:37.560 --> 43:45.480
are, I think you need to understand that software engineers do not know all the answers. You have to

43:45.480 --> 43:51.320
go and read documentations. You have to practice, practice, practice, and put time into it. Countless,

43:51.320 --> 43:59.880
countless hours you need to put into learning. So I mean, this course, I think, is going to be so

43:59.880 --> 44:06.760
many hours long. The way I can, I mean, I can see the planning for all the chapters that I've put

44:06.760 --> 44:12.360
here. There are so many chapters. I think the entirety of this course is going to go over 20

44:12.360 --> 44:17.960
hours. So you can imagine that I can't go into details about every single thing. Otherwise,

44:17.960 --> 44:24.360
it is just, this course is probably going to be like 200, 300 hours. It's unbelievable. So

44:25.000 --> 44:29.720
we can't do that. So what I expect you to do now is just to open your browser and just type

44:29.720 --> 44:38.520
dart maps documentation, something like that, dart maps. So, and you also need to know that now that

44:38.520 --> 44:44.280
you're starting to Google things, you need to be aware of the word dart and that dart is an existing,

44:44.280 --> 44:51.640
very popular name for just darts, darts. Okay. So sometimes depending on what you're Googling,

44:52.520 --> 44:59.160
if a topic related to the classic darts that you throw is more popular than the topic of

44:59.160 --> 45:06.440
the programming language, which kind of sounds the same, it may pop up first. So in this case,

45:06.440 --> 45:13.320
if you say dart map, you may actually end up in some sort of weird website that explains to you

45:13.320 --> 45:19.640
how you can throw darts at a map. I don't know. I'm just trying to bring it up because I actually

45:19.640 --> 45:23.240
ended up in that situation that I searched for something related to dart. I actually ended up

45:23.240 --> 45:28.840
in a weird website talking about darts as like a sport. So know that as well, please.

45:30.840 --> 45:40.040
All right. Now we've talked about maps. So I'm going to take that in my notes. Now

45:40.040 --> 45:51.320
what's coming in the next chapter, we are going to talk about a very important concept in darts

45:51.320 --> 45:56.520
and many other programming languages such as Rust and Swift, and that is null safety or dart calls

45:56.520 --> 46:04.200
it the sound null safety. It is a very important thing to know about in darts and it will greatly

46:04.200 --> 46:09.000
and it will greatly help you in the future as you write your Flutter applications.

46:10.120 --> 46:18.360
In this course, I'm going to use a lot of null. I'm going to make a lot of null references,

46:18.360 --> 46:24.680
talk about null quite a lot throughout the course. So it is very important that we go through that

46:24.680 --> 46:28.120
as soon as possible, and we're definitely not going to leave that out. So

46:29.080 --> 46:36.120
that's going to be for chapter five. So keep an eye out for chapter five that is to follow. So

46:36.120 --> 46:40.440
I hope that you enjoyed this chapter, chapter number four, where we talked about dart control

46:40.440 --> 46:47.720
statements and collections, and I'll see you in the next chapter. Hello everyone, and welcome to

46:47.720 --> 46:54.040
chapter number five of this Flutter course. In this chapter, we're going to talk about null safety.

46:54.840 --> 46:58.200
In the previous chapter, chapter number four, we talked about

46:59.080 --> 47:06.680
dart control statements and collections. And before we go on to talk about enumerations

47:06.680 --> 47:12.360
and objects and classes, I feel it is very important to talk about null safety, which is

47:12.360 --> 47:22.120
a concept that is available in most modern languages such as Rust and Swift. So it is

47:22.120 --> 47:27.480
important to get this out of the way before we continue. Maybe not even get it out of the way,

47:27.480 --> 47:33.800
but actually learn what it means and try to utilize it so that we can write better code.

47:33.800 --> 47:44.920
So I thought to just bring up the concept of null values and why they're important to handle. Well,

47:46.680 --> 47:50.920
you've seen so far that we have data types. A data type can be, for instance, a string,

47:50.920 --> 47:59.240
can be an integer, and then you can put values in them. However, in programming languages,

47:59.240 --> 48:06.920
you are also allowed to have the concept of the absence of a value. So on one hand, you have

48:06.920 --> 48:12.440
values. So you, for instance, have a string value equal to foo bar or your name or whatever it is.

48:13.240 --> 48:17.400
And then on the other hand, you can have the absence of that value. So you can see that,

48:18.200 --> 48:23.640
okay, I have a container, I have a variable that can contain the values of type string,

48:23.640 --> 48:30.760
or I have a variable that can contain any object. However, at the moment, I don't have that value.

48:30.760 --> 48:38.440
So you will just tell Dart that this variable that I have right now can either contain a valid

48:38.520 --> 48:47.720
value of type object or of type string or integer, or it can sometimes also during its lifetime

48:48.920 --> 48:56.440
contain nothing. And this nothingness is the concept that is known as null.

48:58.360 --> 49:06.360
So it's null in Dart is a keyword. It means that it's a word that you can just write in your

49:06.360 --> 49:11.720
text editor as you're writing your code. And you say that a variable's value is equal to null.

49:12.600 --> 49:17.080
And this tells Dart that, well, okay, this variable at the moment doesn't contain any values.

49:17.080 --> 49:24.760
So null is not really a value, but it's actually the absence of a value. You should think of it

49:24.760 --> 49:33.800
that way. So let's have a look at this. There's a little bit of a documentation here.

49:37.160 --> 49:41.720
On Dart's website, Dart dev null safety. So I'm just going to click on it. You're not going to

49:41.720 --> 49:49.320
see my screen at the moment. I'm just bringing it up in a browser, a browser window. I'm going to

49:49.320 --> 49:56.920
bring it on the screen and increase the size a little bit and also change the sizing on the

49:57.240 --> 50:01.720
the window as well. So you can see the contents in its entirety.

50:03.640 --> 50:10.280
So as you can see in Dart, it's called sound null safety. And there's documentation about

50:10.280 --> 50:19.400
what this actually means. We're going to look at what null safety actually means in Dart. And

50:19.400 --> 50:23.560
I'm going to give you a lot of examples of what that actually practically means. And there's

50:23.560 --> 50:30.760
documentation here in Dart's website simply because Dart, in its older versions, not in its

50:30.760 --> 50:36.680
current versions, in its older versions, it didn't support null safety. So there was a lot of code

50:36.680 --> 50:44.120
written manually by programmers in order to, for instance, check whether a value is absent in a

50:44.120 --> 50:50.680
variable. And then there is, as you can see here, it says migrating an existing package or app. So

50:50.680 --> 50:55.720
there is documentation written by the Dart team in order to help developers understand how they

50:55.720 --> 51:02.600
can move their old code to the new code that supports null safety. However, if you're following

51:02.600 --> 51:10.040
along with this course, it's like you're basically just following chronologically from chapter one

51:10.040 --> 51:13.240
to all the other chapters. I don't know how many chapters we're going to have, but if you're

51:13.240 --> 51:16.840
following along with this course, you don't have to think about migrating because the code that

51:16.840 --> 51:20.840
we're writing in this entire course is going to be null safe, meaning that we're going to take

51:20.840 --> 51:27.240
advantage of Dart's null safety operators and meaning that we are not going to manually check

51:27.240 --> 51:32.200
for values being null and then doing some branches of code, whether they're null or not.

51:33.560 --> 51:37.080
So what I mean is that if you read the documentation for sound null safety,

51:37.080 --> 51:40.280
you don't have to worry about the migration parts. Just read the rest. Okay.

51:40.280 --> 51:47.240
So with that out the way, I'm just going to make sure that I tick that in my notes here. That's why

51:47.240 --> 51:53.560
I'm looking in this direction because I have all my notes here. Let's close this window and bring

51:53.560 --> 52:00.440
up our Visual Studio Code window that we had from earlier. I'm going to put it here, and I'm just

52:00.440 --> 52:07.400
going to ensure that it is of the correct height as well. So you're going to see the window in it

52:07.400 --> 52:11.720
height as well. So you're going to see the window in its entirety. Okay.

52:13.560 --> 52:19.560
So now that we talked about what null values are and that there are the absence of a value,

52:19.560 --> 52:26.840
let's have a look at making any type nullable. And if you follow along with the course up to

52:26.840 --> 52:30.440
this point, you should have some sort of a simulator or an emulator running, and then you

52:30.440 --> 52:35.880
should have done command shift P or control shift P depending on your operating system,

52:35.880 --> 52:43.880
command shift P in Mac and control shift P in Linux and Windows in order to bring up this menu.

52:43.880 --> 52:47.560
And then you can just type Flutter, select device, and then you just select the device that you want

52:47.560 --> 52:51.480
to run the code on. So I'm kind of assuming that you've already done that and that your code is

52:51.480 --> 52:55.960
running. And this is something that we talked about in earlier chapters. So we're not going

52:55.960 --> 53:03.080
to go through that again. So I have an iPhone simulator, which you cannot see on the screen,

53:03.080 --> 53:07.800
but I have it running in a separate screen just because we don't have enough real estate. I can

53:07.800 --> 53:11.800
bring it up to this window, but it will just take a lot of space. So I'm going to bring it up to

53:11.800 --> 53:17.320
another monitor so you don't see it. So this code at the moment is running live. So if I press command

53:17.320 --> 53:26.200
S, then it's going to run and just print the output for us. Okay. Now let's talk about making

53:26.200 --> 53:35.560
any type nullable. And there is a way to do that. Let's have a look here. We talked about that null

53:35.560 --> 53:40.360
is a keyword, and that's why you can see it is highlighted here in a different color.

53:40.920 --> 53:48.680
So if you, for instance, say final name is foo, as you can see, it says, okay, I accept this as

53:48.680 --> 53:55.000
name is foo. But you can't just say name like it's a null because then it doesn't understand. Is it

53:55.000 --> 54:01.240
an object? Is it a string? Is it an integer? And if you type here name, then you see it's just

54:01.240 --> 54:07.400
dynamic. It doesn't understand the type. And we'll talk about dynamic a little bit later.

54:08.120 --> 54:13.960
But what you can do is to actually specify that, okay, I want a string data type that

54:14.520 --> 54:20.680
it can contain normal names or strings as we call it, like series of characters, or it can sometimes

54:20.680 --> 54:26.600
be null. And in that case, you have to actually specify the data type as not just string,

54:27.320 --> 54:32.680
not just this, because you'll see, you'll get an error. And we'll actually get a suggestion. It

54:32.680 --> 54:37.480
says, try changing the type of the variable or casting the right-hand type to string.

54:38.360 --> 54:43.160
But we're not going to do that. That wasn't such a, it wasn't such a useful suggestion because

54:43.160 --> 54:48.760
what you want here is to actually make Dart understand that this variable right here,

54:48.760 --> 54:55.000
or this constant right here can sometimes contain the value of null. And the way to do that is you

54:55.800 --> 55:03.160
put the suffix after your data type as a question mark. So this is the syntax,

55:03.160 --> 55:07.320
which is actually using some other languages as well. It's used in Swift as well.

55:08.600 --> 55:15.080
So this tells Dart that, well, here, if we make it actually a variable, as you can see, or sorry,

55:16.040 --> 55:22.840
like this. So you say, I have a variable. It's a string, but sometimes it may,

55:22.840 --> 55:29.960
the string value may be absent. And then you'll just say, okay, now name is foo.

55:30.840 --> 55:36.680
And you can say now name is null. So this is kind of like resetting out names. So if I just say,

55:36.680 --> 55:43.400
okay, print name. And then after foo, I say print name. Okay. So let's just

55:44.040 --> 55:48.120
clear the console and just run this application. You can see the first time it says it's null.

55:48.920 --> 55:56.200
And then the second time around it says it is foo. So this is how you tell Dart that you

55:56.200 --> 56:02.440
want to have nullable data type. And you can do this with pretty much all data types. So you can

56:02.440 --> 56:09.640
just say, okay, I have an integer of age, and that's 20. But you can see you cannot now assign

56:09.640 --> 56:14.040
the value of null to integer because it's not nullable. But as soon as you make it nullable,

56:14.040 --> 56:23.800
then that is accepted. And of course, you can do different operations using, for instance,

56:23.800 --> 56:27.480
in the previous chapter, I believe, we talked about control statements if and else.

56:28.120 --> 56:35.320
So you can say, for instance, if age is 20, and then you can execute some code,

56:35.320 --> 56:42.360
or you can say if age is null, execute some code. So they work as you would expect. So

56:42.360 --> 56:50.600
there is no difference really. And I mean, if you think about that nullability is just like a

56:51.880 --> 56:56.760
suffix to a data type, you can also say, okay, pretty much any data type can be nullable. And

56:56.760 --> 57:04.520
that's great. Like, for instance, if you have a list of string of names, you can say, okay,

57:04.520 --> 57:11.640
I have foo and bar here. This is a list of strings. I talked about lists in chapter four.

57:12.600 --> 57:18.680
Now, you can see here that list of strings, there are two data types here, the list itself,

57:18.680 --> 57:25.720
and the contents that it holds. So if you want to make the list in itself nullable, then you would

57:25.720 --> 57:33.320
put the question mark after. This means this list of strings in itself can be absent. So you say

57:33.320 --> 57:41.000
names null, and that's accepted. However, since you're telling Dart that, okay, the names value

57:41.000 --> 57:47.320
here can in its entirety be null, but its values are not supposed to be null. So if you then go

57:47.320 --> 57:53.080
in here and just put null in here, then you see that you got an error. And that's because Dart

57:53.080 --> 57:58.680
is saying that, okay, you just promised me that the list in itself, it can be absent, but as soon

57:58.680 --> 58:06.040
as it is not absent, meaning that as soon as it is present there with some values, its values cannot

58:06.040 --> 58:13.320
be null. And that means that this type should be telling me here that it is null. So if you want to

58:13.320 --> 58:21.880
make an optional or nullable list of optional strings, then you would put the question mark

58:21.880 --> 58:27.800
after the data type of string as well. So this is now, I mean, the way you should read this is,

58:28.920 --> 58:39.800
I have a list of strings, and I call that list names. Names can sometimes be null, meaning that

58:39.800 --> 58:51.480
it can be absent. And if it is not absent, it can contain objects of type string that themselves

58:51.480 --> 58:58.760
can sometimes be absent, meaning that, okay, for instance, if you say foo bar null, that's accepted,

58:58.760 --> 59:06.360
but you can also say names is null. See what I mean? So both the container, which is called names,

59:06.360 --> 59:11.880
and the values that it contains can be optional. And the word optional is very important for you

59:11.880 --> 59:17.560
to learn. It's kind of like an industry accepted way of talking about nulls and nullable values.

59:17.560 --> 59:26.520
So this is optional, all right? Okay. Now we talked about that,

59:27.960 --> 59:33.560
nullable values and optional values, all right? Basically, you can use those words interchangeably.

59:33.560 --> 59:40.040
So if you're talking with a colleague programmer, you would say, oh, how would you describe this?

59:40.040 --> 59:45.160
Okay, this is an optional list of optional strings. Or you could also say nullable list

59:45.160 --> 59:50.200
of nullable strings. But optional is also a word that is typically used to

59:50.200 --> 59:58.520
talk about nullable values, all right? Okay. We talked about making any type nullable. So

