WEBVTT

00:00.000 --> 00:08.200
I'm just going to mark that as done that we've talked about it in notes, all right?

00:08.200 --> 00:12.200
Now let's talk about cherry picking non-null values.

00:12.200 --> 00:25.080
And what this means is with Dart, you can easily ask the language to give you values

00:25.080 --> 00:26.400
that are not null.

00:26.400 --> 00:29.340
And I'll explain what this actually means.

00:29.340 --> 00:42.740
Let's say that you have a string, a final string, first name, and it is equal to foo.

00:42.740 --> 00:48.060
Now let's just say this is a constant, all right?

00:48.060 --> 00:49.980
That's what the suggestion was, you see?

00:49.980 --> 00:55.540
I wrote final because I was not planning to reassign this first name value to anything

00:55.980 --> 01:03.300
But then I got a suggestion to actually use the keyword const as you can see here.

01:03.300 --> 01:08.580
So let's say const, all right?

01:08.580 --> 01:19.500
Now what we want to do here, then, is to also create a last name or a middle name, r, and

01:19.500 --> 01:25.500
then we say last name, and I have to change the last name to last name, right?

01:25.500 --> 01:31.900
Actually, what we're going to do is we're going to say the first name is null, all right?

01:31.900 --> 01:36.580
So first name null, middle name bar, and last name bass.

01:36.580 --> 01:42.140
Now if you want to, if you have these values and you want to, for instance, I mean, right

01:42.140 --> 01:46.220
now you can actually see the values that you put here, but sometimes these values are passed

01:46.220 --> 01:48.900
to your function, so you don't know what they are.

01:48.900 --> 01:50.780
Right now you can see what they are, so it's easy.

01:50.780 --> 01:55.820
If I told you, pick the first non-null value, then you would say middle name because you

01:55.820 --> 01:56.820
can see it.

01:56.820 --> 02:01.420
However, if you had a function, for instance, test here that accepted those values, for

02:01.420 --> 02:09.580
instance, string, first name, string, last name, and then string, or yeah, middle name,

02:09.580 --> 02:15.700
etc., then you wouldn't know what those values are, or you cannot make an assumption about

02:15.700 --> 02:19.940
what those values are except that they are nullable or optional strings.

02:19.940 --> 02:23.140
So I hope that you get what I'm trying to say.

02:23.140 --> 02:29.980
If someone told you to pick the first non-null value, one way to do that is, like the old

02:29.980 --> 02:42.500
way of doing that is to say, if first name is not null, then you would say, oh, okay,

02:43.220 --> 02:51.620
first name is the first non-null value, okay?

02:51.620 --> 02:58.860
And then you say, okay, if first name isn't null, then we pick it, otherwise, else, if

02:58.860 --> 03:02.740
middle name is not null, okay?

03:02.740 --> 03:10.260
And then you say, okay, middle name is the first non-null value, and then else, if, again,

03:10.340 --> 03:15.140
last name is not null, then you would print the same thing.

03:15.140 --> 03:16.580
So this is very repetitive.

03:22.660 --> 03:27.780
So it is basically very verbose in the way it is created.

03:29.300 --> 03:35.220
There is a better way of doing this, and that is with the question mark, question mark operator

03:35.300 --> 03:40.100
in Dart, which is available in some other programming languages such as Swift as well.

03:40.980 --> 03:45.060
So the way to do that, then, is you would want to pick the first non-null value.

03:45.060 --> 03:53.140
So you would say, final or const first non-null value, and you would say that's equal to first

03:53.140 --> 03:55.540
name or or.

03:55.540 --> 04:01.460
So this is kind of like question mark, question mark, middle name, and then question mark,

04:01.460 --> 04:02.580
question mark, last name.

04:02.740 --> 04:07.780
So, and, I mean, we're getting a warning here just because Dart understands already that

04:07.780 --> 04:14.020
this middle name, although a, so, this is, although an optional, basically, it has a value.

04:14.820 --> 04:21.220
But if we meet this null, so, and that warning goes away, but, I mean, it would probably

04:21.220 --> 04:25.700
be cleaner if we actually pass these as parameters into this function so we don't get these weird

04:25.700 --> 04:26.820
warnings.

04:26.820 --> 04:31.220
But the way the question mark, question mark operator is working is that it says, it is

04:32.180 --> 04:37.300
an infix operator, just so you know, in, from chapter four, you know, an infix operator is

04:37.300 --> 04:42.500
an operator that has two things, one on each, on each side, the right and left.

04:43.380 --> 04:47.140
So in this case, on the right side, we have middle name, and on the left side, we have

04:47.140 --> 04:47.620
first name.

04:47.620 --> 04:53.460
So what this operator does, it says, if the value on my left side is null, I'm going to

04:53.460 --> 04:54.660
pick the value on my right.

04:55.220 --> 04:55.540
Okay.

04:56.580 --> 05:00.340
And let's now, in this case, say, okay, middle name is not null.

05:00.340 --> 05:03.300
So what it does, it says, first name, are you null?

05:03.300 --> 05:04.100
Yeah, you're null.

05:04.100 --> 05:05.460
Then I'm going to go to the right side.

05:05.460 --> 05:06.580
Middle name, are you null?

05:06.580 --> 05:07.700
Nope, I'm not null.

05:07.700 --> 05:12.660
Then it's going to pick that, and the rest of the statement is not going to be executed.

05:14.180 --> 05:19.380
However, if middle name was also null in this case, then what happens is that it begins

05:19.380 --> 05:22.260
from the left, it says, first name, are you null?

05:22.260 --> 05:22.980
Yes.

05:22.980 --> 05:24.420
Middle name, are you null?

05:24.420 --> 05:25.140
Yes.

05:25.140 --> 05:31.620
So this entire operation here, it doesn't yield any value.

05:32.980 --> 05:35.780
So this entire operation will let me know.

05:35.780 --> 05:40.660
So it says, okay, now I have to compare our left-hand side.

05:40.660 --> 05:41.140
Are you null?

05:41.140 --> 05:43.460
Yeah, we know that this entire thing was null.

05:44.340 --> 05:46.580
And then it says, right-hand side, are you null?

05:46.580 --> 05:48.180
Nope, I'm bass.

05:48.180 --> 05:49.060
Then it picks bass.

05:49.060 --> 05:55.700
So this question mark, question mark operator is a null-aware operator that picks either

05:55.700 --> 06:01.940
the left side or the right side, whichever one is not null first in that order.

06:01.940 --> 06:03.620
So left side, are you null?

06:04.420 --> 06:06.180
If you're null, I go to the right side.

06:06.180 --> 06:09.060
But if you're not null, I'll pick you.

06:10.500 --> 06:11.780
So keep that in mind.

06:11.780 --> 06:17.220
It is a very handy operator, and it will shorten your code quite a lot.

06:17.220 --> 06:17.720
All right?

06:18.520 --> 06:22.920
Now, if we then go in here and say first, null, null value, you can see it actually says,

06:22.920 --> 06:23.880
oh, it's a string.

06:24.840 --> 06:33.080
However, if these were parameters, so if we said first name, and then string, last name,

06:33.080 --> 06:39.480
sorry, middle name, last name, so they were not provided to us like that,

06:41.480 --> 06:43.560
contour was okay, and then we say final.

06:43.560 --> 06:52.280
Now, if we say first, non-null value, in this case, since it is a normal case, excuse me,

06:53.320 --> 06:56.360
where the Dart compiler isn't working with constants,

06:58.760 --> 07:03.160
then it cannot resolve this to a constant value at the moment.

07:03.160 --> 07:05.320
So it says, okay, there are three optional values.

07:05.320 --> 07:07.080
I have no idea what they are.

07:07.080 --> 07:11.560
So I'm going to do my best to pick the first non-null value depending on, I mean,

07:11.560 --> 07:13.480
based on what we provided here.

07:14.680 --> 07:16.920
However, I may not be able to solve this.

07:16.920 --> 07:22.360
So the final result here, as you'll see, is an optional string, meaning that, well,

07:22.360 --> 07:27.800
I may not be able to resolve this, meaning that this entire operation on top on line nine

07:27.800 --> 07:29.400
may result in a null.

07:30.680 --> 07:31.180
All right?

07:32.600 --> 07:33.240
Sorry about that.

07:33.240 --> 07:34.120
Sorry about my voice.

07:35.560 --> 07:39.400
So that is the question mark, question mark operator.

07:39.400 --> 07:43.560
So I'm just going to mark that we talked about it in my notes.

07:45.400 --> 07:45.900
Okay.

07:47.560 --> 07:49.240
So that was that.

07:51.800 --> 07:59.320
Now, let's talk about the next topic, which is the null aware assignment operator.

07:59.320 --> 08:01.480
I think that's its actual official name.

08:03.480 --> 08:07.720
This operator is very similar to the question mark, question mark operator in that it

08:09.640 --> 08:14.680
tries to resolve a variable to make sure it is not null.

08:15.240 --> 08:16.280
It's going to do its best.

08:17.080 --> 08:18.840
And let's have a look at an example.

08:18.840 --> 08:22.840
Let's just say bar.

08:23.640 --> 08:30.200
I'm going to say, actually, let's just say string and name is first name.

08:30.200 --> 08:35.960
So we begin, we say that we have an optional name and we begin by assigning first name to it.

08:35.960 --> 08:41.480
So it means that its name might, at the moment, depending on the value of first name, it may be

08:41.480 --> 08:41.980
null.

08:42.840 --> 08:48.040
Now, if that is null, you may want to assign another value to it.

08:48.040 --> 08:49.000
All right?

08:49.000 --> 08:51.000
And then you can do that with this operator.

08:51.000 --> 08:52.200
You would say last name.

08:53.880 --> 08:54.840
Let's see what happened here.

08:55.720 --> 08:58.040
We'll try to, oh, is it this?

08:58.040 --> 08:59.560
Yes, it is equal to.

08:59.560 --> 09:06.520
So I actually should change this case to equal to question mark.

09:07.560 --> 09:08.280
Yes.

09:08.280 --> 09:11.800
And I'm going to bring it up again so that it is actually correct, let's say.

09:14.440 --> 09:17.800
And then name equal to, isn't this working?

09:19.160 --> 09:23.640
Last name, oh, where was it this one?

09:25.320 --> 09:26.200
Try changing the,

09:26.200 --> 09:29.640
is it like this?

09:31.640 --> 09:33.320
I'm actually a bit unsure right now.

09:33.320 --> 09:35.160
So let's have a look, actually, what this does.

09:37.400 --> 09:39.000
And it's a three-positional.

09:39.000 --> 09:45.080
And then we say null, null, null, and then bar, and then bass here, okay?

09:45.080 --> 09:50.680
So first name is null, middle name is bar, and last name is bass.

09:50.680 --> 09:54.280
And to be honest with you, I mean, this is quite a lot for me as well.

09:54.280 --> 09:58.680
It is something that is like the syntax of the programming language.

09:58.680 --> 10:01.480
It is something that you will kind of need to live with.

10:01.480 --> 10:05.320
You're not going to memorize this all just in your head all the time.

10:05.320 --> 10:11.240
Of course, like the main parts of it, you're going to remember, but not all of it.

10:11.240 --> 10:15.640
So, and you can see for me as well, I'm just like at the moment, okay, which one is it?

10:16.760 --> 10:17.720
So I'm going to test that.

10:17.720 --> 10:20.840
So to begin with, we say name is first name.

10:20.840 --> 10:25.800
And if that is null, then assign, actually, let's just say middle name,

10:27.160 --> 10:29.960
name here, then use middle name, and then print the name finally.

10:30.600 --> 10:32.200
And I can see it says bar here.

10:32.200 --> 10:34.600
So it's actually question mark, question mark equal.

10:37.080 --> 10:41.240
So I actually maybe need to edit this text one more time.

10:41.240 --> 10:44.200
So I'm just going to say question mark, question mark equal.

10:45.400 --> 10:47.960
Bring it up because I think question mark equal is not going to work.

10:47.960 --> 10:49.880
An equal question mark isn't going to work either.

10:50.840 --> 10:51.880
It's not a valid syntax.

10:51.880 --> 10:53.240
So question mark, question mark equal.

10:53.240 --> 10:53.880
Sorry about that.

10:54.520 --> 10:58.600
So what this operator at the moment is doing is says that I'm going to take

10:58.600 --> 11:02.040
the value on the left-hand side and check whether it is null or not.

11:02.040 --> 11:07.480
If it is null, then I'm going to assign the value on the right-hand side to the left-hand side.

11:08.680 --> 11:11.800
If it is not null, I'm going to leave it alone.

11:13.480 --> 11:17.400
So at the moment, first name, as you saw here, is null,

11:17.400 --> 11:19.080
the first parameter that we pass here.

11:19.880 --> 11:25.240
What it says is, okay, I'm going to check then for middle name if name is null.

11:25.240 --> 11:26.120
And it is null.

11:26.120 --> 11:29.480
And then it says, okay, middle name, are you present there?

11:29.480 --> 11:30.920
And then we'll assign that value here.

11:30.920 --> 11:37.640
So it will be basically it will be bar, which is the value of the middle name.

11:38.840 --> 11:44.280
Now, if we in here said middle name is also null,

11:45.080 --> 11:50.920
right, you could have another operator here that says, okay, if after taking the middle name,

11:50.920 --> 11:53.400
we are still null, then take the last name.

11:54.600 --> 11:59.480
So, and you can see Baz gets printed to the screen.

11:59.480 --> 12:04.680
And that is because because Baz is the last parameter that we're checking on line 10.

12:05.400 --> 12:06.840
And its value is not null.

12:08.360 --> 12:13.800
So you can see how like if I then went here and actually said the value is not null,

12:14.040 --> 12:15.800
the first name is bar.

12:15.800 --> 12:19.160
Then you will see that that will be the value that gets printed to the screen here.

12:20.200 --> 12:26.920
Because right here, name or first name, which is bar, got assigned to name.

12:26.920 --> 12:30.360
So it is an optional string, but it has a value, which is bar.

12:31.000 --> 12:34.520
Then when you come to this line number nine, then you're telling Dart,

12:34.520 --> 12:38.680
look, if name is null, then assign middle name to it.

12:38.680 --> 12:42.360
And Dart says, well, name is a null, it is bar.

12:42.360 --> 12:44.440
So I'm not going to assign middle name to it.

12:44.440 --> 12:46.920
And then it goes to line number 10 and does the exact same thing.

12:46.920 --> 12:47.240
All right.

12:48.440 --> 12:52.120
So that is like the null aware assignment operators.

12:52.120 --> 12:54.760
And it is useful.

12:55.640 --> 12:58.360
I personally, I mean, to be honest with you, I,

12:58.360 --> 13:02.200
as you could kind of guess, I don't use this operator so often.

13:02.200 --> 13:03.000
It is there.

13:03.960 --> 13:08.680
And I have no shame in saying that pretty much in none of my programs have I had to use this.

13:09.320 --> 13:11.880
It is present for you to use.

13:11.880 --> 13:13.880
It is available if you want to use it.

13:13.880 --> 13:19.320
So just don't be like me, but try to remember the syntax is question mark, question mark equal.

13:22.440 --> 13:25.640
And I'm going to actually fix that in my notes as well,

13:25.640 --> 13:28.280
that it is question mark, question mark equal.

13:31.480 --> 13:33.880
And I'm going to check it in the notes that we've talked about it.

13:34.360 --> 13:45.800
Now, let's talk a little bit about conditional method or property access or conditional invocation.

13:47.080 --> 13:52.520
Now, as we talked about in the previous chapter, with Dart, as like many other

13:52.520 --> 14:00.920
programming languages, you can use the dot syntax in order to access or drill down inside properties

14:00.920 --> 14:03.640
and methods or functions inside other objects.

14:03.640 --> 14:09.560
As we saw, for instance, with the case of lists in Dart, you can say,

14:10.440 --> 14:13.720
I have a list and then you want to get its length, then you would say

14:15.000 --> 14:17.640
the name of the list dot length.

14:17.640 --> 14:21.160
And that drills down inside that list and gets the length property.

14:23.160 --> 14:27.160
However, as you saw earlier in this chapter, in chapter number five,

14:27.960 --> 14:32.280
even lists or pretty much any data type in Dart can also be nullable.

14:32.760 --> 14:39.160
So how do you access properties of a null object?

14:39.160 --> 14:40.680
So let's have a look at that now.

14:42.040 --> 14:47.800
Let's say I'm going to actually delete these properties, the parameters that come here to

14:47.800 --> 14:53.800
our function, and I'm going to say, and I'm going to go down here and remove these parameters as

14:54.200 --> 14:54.440
well.

14:56.440 --> 15:01.800
And in here, let's just create an optional list of strings.

15:02.360 --> 15:07.640
Not optional list of optional strings, but just an optional list of valid strings.

15:07.640 --> 15:07.880
Okay.

15:07.880 --> 15:14.760
So I'm just going to say list of strings as an optional list, and I'm just going to say names,

15:15.320 --> 15:18.120
and that is equal to, let's just say at the moment, foo.

15:18.120 --> 15:18.440
All right.

15:19.400 --> 15:29.960
Now, here, if you try to say final length of names or number of names is names, length, okay?

15:31.320 --> 15:36.040
If you then look at the data type here, I mean, we could actually say this is null.

15:38.440 --> 15:47.160
And you can see here, Dart actually is allowed to or is able to give you an error knowing that this

15:47.240 --> 15:50.040
list is null at the moment.

15:50.040 --> 15:54.280
However, if you accept it, I think it's actually better that we accept this value as a parameter

15:54.280 --> 16:00.520
so that Dart analyzer cannot be too smart about making assumptions about what this actually is

16:00.520 --> 16:01.160
at the moment.

16:02.040 --> 16:08.680
So you can see the analyzer is telling you it cannot be unconditionally accessed because

16:08.680 --> 16:14.200
the receiver can be null, and that means, yeah, exactly as it says, it says names can be null.

16:14.200 --> 16:17.480
I don't know if it's null right now or not, but it can be.

16:19.000 --> 16:20.520
So how do you access that?

16:20.520 --> 16:27.080
One way to do that, like, the old way of doing that is to say if names is not null,

16:27.960 --> 16:31.240
then length is names length, okay?

16:33.240 --> 16:37.480
Final length is names length, okay?

16:37.480 --> 16:42.120
So that tells Dart that, look, I'm actually checking for null values,

16:43.080 --> 16:49.640
or I'm checking that this list is not null on line 8, and if it is not null,

16:50.200 --> 16:52.760
then I will access its length property.

16:52.760 --> 16:58.360
And this is kind of, it's called type promotion, and type as in data type.

16:59.080 --> 17:04.840
So in this case, you can see on line number 8, or now if I go and create a new line on

17:04.840 --> 17:10.120
number, on line number 8 and I say names, this is an optional list

17:10.360 --> 17:19.000
that can contain strings, and in here, you can see it is type as the same, but it is promoted

17:19.000 --> 17:25.320
to not being null because you've already checked for it, because if you remove these lines of code,

17:25.320 --> 17:29.640
you can see now that you get an error, the exact same line, but if you check first for null,

17:29.640 --> 17:32.520
and you don't get the error, it's a type promotion, okay?

17:33.400 --> 17:35.400
So this is kind of like the old way of doing that.

17:35.400 --> 17:40.680
So let's say that you want to have, you want to extract the length, so you say final length,

17:40.680 --> 17:45.080
or ints length, right? You create the variable, but you don't assign anything to it.

17:46.040 --> 17:50.280
Then you say if names is not null, then the length is equal to the name's length.

17:50.280 --> 17:54.520
Otherwise, length is zero, okay? So this is one way of doing that.

17:55.560 --> 17:57.000
It's the old way of doing that.

17:57.160 --> 18:02.760
And you may be trying to be smart as well and say, okay, I don't need this else statement if I just

18:02.760 --> 18:07.960
say this is a variable, and by default, it's zero, and yeah, you would be right, because length is

18:07.960 --> 18:13.160
zero by default, and then if names is not null, then you say, okay, length is equal to name's length.

18:14.200 --> 18:20.920
However, there's a better way of doing that, and that is using the dot question mark,

18:20.920 --> 18:26.200
I believe, or the question mark that actually it is, yeah, operator, which conditionally executes

18:27.080 --> 18:33.800
or invokes a method or a property inside an optional if that optional value is present.

18:34.600 --> 18:37.400
I'm going to show you how to do that. So if we say final length

18:39.960 --> 18:44.280
is names, and then you would put question mark dot, and then you would say length,

18:44.280 --> 18:48.200
and you would say, okay, length is equal to name's length, and then you would say

18:48.200 --> 18:52.360
question mark dot, and then you would say length, and you would see this code being

18:52.360 --> 18:57.960
executed without a problem. However, if you go here, you would see that length is an optional

18:57.960 --> 19:03.240
value, is an optional integer. So you may be like, okay, how do I solve that? How do I say that

19:05.720 --> 19:17.320
I want length to be zero if this length value is null, meaning that if the names list is null and

19:17.320 --> 19:22.600
we can't extract the length, then I want this value to be set to null. And that is using our

19:23.160 --> 19:28.440
question mark, question mark operator that we talked about, the null operator that we talked

19:28.440 --> 19:36.520
about earlier, the infix operator. So you could just do this. You would say length is if the names

19:36.520 --> 19:42.600
list is present, meaning that its value is not null, then grab its length. Otherwise, take the

19:42.600 --> 19:47.960
value of zero and assign its length. And if you go to line number nine now and I say length, you can

19:47.960 --> 19:58.360
see it's an integer. So it's not an optional integer anymore. So you could do the same thing

19:58.360 --> 20:03.400
as well. Like you could say names, and you could do the same thing with properties, and you could

20:03.400 --> 20:11.000
also do it for functions. So you can say names, add, adds, right? So you see this is a function

20:11.720 --> 20:18.040
and then we're adding the value of bass to that list. However, you can't unconditionally invoke

20:18.040 --> 20:29.160
this function on an optional value because it might be null. All right? So that is like a very,

20:29.160 --> 20:37.240
very important bit of learning about darts, learning about optionals in darts, how you could use

20:38.200 --> 20:47.960
nullable values. And as you will see, and we'll talk about more in this course, there is many

20:47.960 --> 20:57.800
cases where you have to take into consideration null values. And especially if you're working

20:57.800 --> 21:03.320
with different libraries where the library cannot make too many assumptions and your code is

21:03.320 --> 21:09.240
dependent on that library and you will have to take into consideration, okay, the absence of

21:09.240 --> 21:16.040
a value means that I personally have to take some decisions in my code consciously in order to

21:16.040 --> 21:21.640
execute bits and pieces of code depending on the absence or presence of the value. So try to use

21:21.640 --> 21:29.880
these optional null aware operators that I taught you here, which was the null aware, basically

21:29.880 --> 21:34.040
the decision making to pick, like the in fix operator that tells you whether the left hand

21:34.040 --> 21:37.880
side or the right hand side, depending on which one is not null first, it picks that one, okay?

21:38.440 --> 21:44.920
That operator is very important and the all aware invocation operator, which is here, so you see

21:44.920 --> 21:52.600
some object which may be null, then do something on it. Or the operator, which is a null aware

21:52.600 --> 21:57.480
assignment operator that assigns the value on the right to the variable on the left should the

21:57.480 --> 22:02.280
variable on the left be null, all right? So these are very, very important to understand.

22:05.640 --> 22:12.760
Okay, now that we've talked about that, I'm going to take that in my notes that that is a topic we

22:12.760 --> 22:22.760
talked about. Now, we also have very, very good official documentation about null safety in Dart.

22:22.760 --> 22:29.320
So I'm going to bring up this documentation on a separate screen, and then I'm going to bring it

22:29.320 --> 22:37.640
up here so you can actually see as well, all right? You can see here it says understanding

22:37.640 --> 22:45.560
null safety, and this is great, great documentation about how null safety in Dart works. As you can

22:45.560 --> 22:52.520
see, a lot of examples. I mean, it talks about like from the absolute beginning,

22:53.960 --> 23:01.080
what it actually means, and you can see here null is at the level of object, so it's not,

23:01.080 --> 23:06.120
null itself is not like an object. So you have lists and doubles and integers here,

23:06.120 --> 23:11.320
but null sits on top for itself, kind of like the absence of a value.

23:12.040 --> 23:16.920
So there's lots of examples in this link, and I highly encourage you to have a look at it.

23:16.920 --> 23:21.560
Some things you may not understand, for instance, like this one, you will understand easily because

23:21.560 --> 23:26.760
it says there is something called a thing, like a class, but we haven't talked about classes yet,

23:27.320 --> 23:33.720
and it's name, parameter name here in this function called show gizmo is called thing,

23:33.800 --> 23:41.560
show gizmo is called thing, and you can see it is conditionally accessing a property on that thing.

23:44.440 --> 23:52.200
And then if that property in itself is null, it conditionally access that as well. So this

23:52.200 --> 23:56.840
property is nullable, and then it's accessing another property inside that nullable property

23:57.560 --> 24:01.960
if it's not null. So I mean, it's a great way you can chain them, as you can see here.

24:02.920 --> 24:08.520
Then so if this thing is not null, then conditionally accesses this property on that.

24:08.520 --> 24:13.160
So it's beautiful. I mean, and this thing is available on many other languages like Rust

24:13.160 --> 24:20.120
and Swift as well. So it's nothing new, but it is kind of like such an important topic to understand

24:20.120 --> 24:24.760
in Dart that I think you shouldn't just skim over it. So you should just really learn how to work

24:24.760 --> 24:35.240
with it. All right. We've now talked about null values. So I'm going to take that in my notes

24:35.240 --> 24:43.560
here. Now, I think for chapter five, this information is enough so that we can move on to

24:44.120 --> 24:51.400
the next chapter. And in the next chapter, chapter number six, we're going to talk about some really,

24:51.400 --> 24:57.880
really juicy stuff. And this is like chapter six is going to be like, as I can see in my notes,

24:57.880 --> 25:04.280
I've pressed in a lot of really interesting topics such as enumerations, classes, objects,

25:05.160 --> 25:11.000
custom operators, constructors, factory constructors, class methods, I mean, inheritance

25:11.000 --> 25:20.920
and subclassing, abstract classes. So as you may have heard, depending on what background you have,

25:20.920 --> 25:26.120
you may be like a product owner or product designer, a UXer or whatever. You may not have

25:26.120 --> 25:34.680
like a software engineering background, but Dart in its core is an object-oriented programming

25:34.680 --> 25:41.320
language. It means that things in Dart are objects. An object is an instance of a class,

25:41.320 --> 25:48.360
as we'll talk about in the next chapter. So for you to understand Dart and how these things work,

25:48.360 --> 25:53.080
for instance, we've talked about lists and actually typing dots in front of the name of

25:53.080 --> 25:57.400
list and getting its length, but you may not really know how that works. So in order to

25:57.400 --> 26:02.760
understand all those things, what that dot means, you need to understand what objects are. And in

26:02.760 --> 26:07.880
order to understand objects, you need to know what classes are. And when you understand classes,

26:07.880 --> 26:13.800
then you will learn about inheritance and then we'll talk about abstract classes, properties,

26:13.800 --> 26:20.520
static functions, all that. So what we're going to talk about in chapter six is so important that

26:20.520 --> 26:26.200
I believe that every Dart developer needs to know about this. And we're learning all of these things

26:26.200 --> 26:33.720
to become good at doing Flutter. So although you can go and write like servers, maybe server

26:33.720 --> 26:38.520
applications with Dart, or you could write command line applications with Dart, but these days,

26:39.160 --> 26:44.840
Dart is primarily used for writing Flutter applications. And I don't have any data to

26:44.840 --> 26:49.640
prove that, but I can see for myself when I'm in the community that most people are using Dart

26:49.640 --> 26:54.920
primarily to write Flutter applications. So we're doing all of this to learn more about Flutter.

26:54.920 --> 26:58.920
And I highly recommend that you don't skip these chapters where we're talking about Dart,

26:58.920 --> 27:04.040
especially if you're new to Flutter development. So with that said, let's leave this chapter

27:04.040 --> 27:08.520
the way it is right now. Chapter number five, we're done with that. Let's go to chapter number

27:08.520 --> 27:15.320
six and learn about Dart enumerations and objects. Welcome to chapter six of this Flutter course.

27:16.040 --> 27:22.920
In this chapter, we're going to talk about Dart enumerations and objects. These are some of my

27:22.920 --> 27:29.560
favorite things to actually talk about. So in most programming languages, actually you have the same

27:29.560 --> 27:35.480
facilities. So if you follow along with the other chapters, then you should have a working

27:35.480 --> 27:40.600
Dart project set up now and maybe running in an emulator or a simulator so that you have

27:40.600 --> 27:45.640
the ability to press command S on Mac or control S in Linux and Windows in order to rerun your

27:46.440 --> 27:52.040
project. So without you having to pretty much do anything. So let's then get started. I'm just

27:52.040 --> 27:56.680
going to make that assumption that you're already set with those requirements.

27:58.840 --> 28:06.680
So let's start by talking about enumerations and I'm going to bring up the project from

28:06.680 --> 28:11.320
the previous chapter. Let's just make sure that it's on the screen so you can easily see it.

28:12.120 --> 28:17.640
Now I'm going to go to this list function that we created, remove the only parameter there and

28:17.640 --> 28:22.520
remove that as well. So if I press command S now, nothing should happen on the screen because we

28:22.520 --> 28:28.040
don't have any functionality in test. So let's talk about enumerations and what they actually are.

28:28.040 --> 28:34.680
As you can see here, enumerations are named list of related items. Now, an enumeration is

28:35.240 --> 28:42.360
kind of like equivalent of making a string written programmatically so that it becomes an entity.

28:43.320 --> 28:52.600
And by that, I mean that let's say you have the value name and then you could say foo.

28:53.240 --> 28:59.880
And you would also say const other name. That's also foo. They're both the same string, but they're

28:59.880 --> 29:05.720
not the same identity in that. I mean, internally, actually, in terms of const, I don't want to go

29:05.720 --> 29:10.120
too much into how the compiler actually works, but they're kind of going to be the same string.

29:10.680 --> 29:15.480
But I mean that you've written it twice, so it's not the exact same thing. You have to write it

29:15.480 --> 29:24.760
twice. So an enumeration tries to basically make sure that a value has a name that can be

29:24.760 --> 29:33.160
programmatically referred to. So let's say enum, and that's a keyword in Dart. That's how you

29:33.160 --> 29:39.400
create an enumeration. I'm going to take this that we've talked about some of the things

29:39.400 --> 29:44.600
during the intro. Sorry about that. I have to look at my notes. Anyway, so we have the enum here.

29:44.600 --> 29:51.080
That's how you create an enumeration in Dart. And you would then give a name to your enumeration.

29:51.080 --> 29:58.040
And unlike variables and constants that are written with camel case, you'd have to basically use

29:58.040 --> 30:04.040
another case in here, which is the first letter of every word in your enumeration's name has to be

30:04.040 --> 30:09.880
uppercase, and the rest of the letters have to be lowercase. So let's in this case, for instance,

30:09.880 --> 30:17.720
say person properties, the properties of any person. Then in this enum, you will write the

30:17.720 --> 30:24.360
different properties, for instance, first name, last name, age. So what that basically means is

30:24.360 --> 30:30.360
that you've now defined a list of related things, such as first name, last name, age, which are

30:30.360 --> 30:37.400
categorized under a particular name, which in this case, person properties. And you can refer

30:37.400 --> 30:43.960
to these in your code using the dot notation. So you can say person, properties, dot, first name.

30:45.160 --> 30:49.880
And you can print it, actually. So I'm just going to press Command S and you can see it being printed

30:49.880 --> 30:58.200
to the screen. So enumerations are really, really great as we go on in learning about Dart and how

30:58.200 --> 31:05.320
Dart works, how we can work with Flutter, how we can parse data that comes back from a server,

31:05.320 --> 31:12.440
for instance. But for now, it's enough for you to understand that you can categorize related items

31:13.480 --> 31:18.280
under an enumeration so that you can refer to them later, okay? And in Dart, you can also get

31:18.280 --> 31:25.400
the string representation of these values using their name property. That is something that's

31:25.400 --> 31:31.320
created for you by default. So if you just say name, you now see first name being printed to

31:31.320 --> 31:37.240
the screen as a string. But before that, if you printed the enumerations in on value here for

31:37.240 --> 31:45.320
first name, it would print out the entire thing, okay? So that's short and sweet about enumerations.

31:45.320 --> 31:52.120
We're going to use them quite a lot, actually, especially later where we go to more advanced

31:52.120 --> 31:58.360
topics as we develop our real application. But for now, just know that this is how you create

31:58.360 --> 32:02.360
an enumeration using the enum keyword and then the rest of the properties you just put in curly

32:02.360 --> 32:12.600
brackets, okay? So that's for enumerations. Now we need to talk about switch statements. And

32:12.600 --> 32:17.240
actually, let's bring this back and I'm going to change these two properties, let's say, okay?

32:17.240 --> 32:26.120
And let's just say, for instance, animal type. And let's say cat, dog, and then let's say rabbit.

32:30.120 --> 32:38.280
So let's say we have an animal type enumeration. And we want to, and then we, for instance, get

32:38.280 --> 32:44.200
in our function, we say animal type, animal type. So there's a property that we expect

32:44.200 --> 32:49.560
to be passed to our function called animal type and then we name that property animal type with

32:49.560 --> 32:54.600
camel casing here, okay? So if we do that, then we go to our function here where we're calling

32:54.600 --> 32:58.760
the function, you can see that we got an error, meaning that there is a parameter expected of type

32:58.760 --> 33:05.720
animal type and no one's passing that. So at the call site, which is the place you're calling your

33:05.720 --> 33:11.320
function, that's what a call site is known as in programming. So if you're coming from a background

33:11.320 --> 33:16.440
of design or anything that is not software development related, so you wouldn't probably

33:16.440 --> 33:22.440
know so much about this kind of lingo, but a call site is where you're calling a function. So

33:22.440 --> 33:29.720
at this call site, number 19, we're then going to pass an animal type and let's just say

33:30.440 --> 33:36.840
cat in this case, okay? So in here, we could just print that. I'm just going to say animal type.

33:37.400 --> 33:43.000
I'm going to press command S and you can see cat being printed here, okay? Now, if you want to

33:43.000 --> 33:50.840
execute different types of code depending on this animal type, then you could, which is not

33:50.840 --> 33:57.080
recommended, you could use an if statement. So if you just said, if animal type is equal to animal

33:57.080 --> 34:10.120
is equal to animal type cat, you'd say print all I love cats, okay? Else if animal type is animal

34:12.920 --> 34:19.240
dog, then you would say print or you would say dogs are still fluffy or something.

34:19.240 --> 34:27.800
And else if animal type is animal type

34:30.120 --> 34:39.800
and I wish I had. All right, so this is using normal if statements. You say if animal type is

34:39.800 --> 34:46.200
cat, then blah, blah, if blah, blah. Now, it is one way of doing it, but it's not the recommended

34:46.200 --> 34:49.880
way of working with enumerations and the recommended way of working with enumeration,

34:49.880 --> 34:54.680
especially if you're doing like branching code as we're doing here, is using a switch statement. So

34:55.240 --> 35:03.160
let's convert this code to switch. So let's say switch. You put parenthesis, open, close,

35:03.160 --> 35:07.800
and then open, close curly brackets. And in here, you would put your enumeration. So you say animal

35:07.800 --> 35:14.040
type, okay? And the way to handle these different branches then is with the case keyword. You'd say

35:14.040 --> 35:24.600
in the case of animal type, bunny, print bunny, something like this, okay? Case animal type,

35:25.640 --> 35:40.600
cat, print cat. And case animal type, dog, print dog. Just like that, okay?

35:41.480 --> 35:47.480
Now, this is I'm actually grateful that we're getting this error so you can clearly see what

35:47.480 --> 35:52.520
it says. Is that the case should not complete normally, try adding break or return. Now,

35:52.520 --> 35:57.320
what this is saying that you see in many programming languages, just like Dart,

35:57.320 --> 36:03.000
when the program comes here to the case statement, it kind of like falls through to the next line.

36:03.000 --> 36:07.960
And Dart tries to avoid that. So it says, okay, if I handle bunny, then I'm doing some stuff,

36:07.960 --> 36:12.200
but it kind of feels like I'm falling down to the next line after this because you didn't tell me

36:12.200 --> 36:19.160
what to do after the print statement. So you either tell me to completely go out of this function,

36:19.160 --> 36:24.200
go out of the test function by putting the return keyword here. We haven't talked about return

36:24.200 --> 36:29.560
really yet. But you could do that. You could just say, okay, return right after all of these. So

36:29.560 --> 36:34.280
I'm just going to press command S, and you will see cats being printed to the screen, which is

36:34.280 --> 36:41.400
here. But if you didn't have this return statement here, you would get an error. So you either say

36:41.400 --> 36:47.240
return or you would use the break keyword. Now there's a difference between these. Let's put

36:47.240 --> 36:52.760
a print statement here, and I'm going to say function is finished. So I'm kind of expecting

36:52.760 --> 37:02.680
that by executing our code here, our test function here, passing the value of cat at the moment,

37:02.680 --> 37:08.840
that we fall into the switch, we check that this is cat and then print the cat, and then we return.

37:10.040 --> 37:15.320
This is kind of what it is doing. It means that it kind of skips over this print statement,

37:15.320 --> 37:19.960
and you'll see soon. If I say command S, it will just say cat and then we'll return from that.

37:20.680 --> 37:25.160
So this is not really what I wanted. I wanted this switch statement to be executed,

37:25.160 --> 37:30.600
print cat, and then continue after switch. And that's where you use the break statement,

37:30.600 --> 37:36.280
so or the keyword here. So if you say break, it breaks out of the switch statement and then

37:36.280 --> 37:41.080
continues with the rest of the function as you would expect. So if I press command S here,

37:41.080 --> 37:48.520
you say cat, and then function is finished. All right. So switch is the preferred way of working

37:48.520 --> 37:53.800
with enumerations, especially if you're doing branches. So you could also like,

37:54.440 --> 38:06.280
for instance, if in this case you said make sure this is a cat, you could also in this case say,

38:06.280 --> 38:15.720
if animal type is not animal type, cat, and you would return. Okay? You could do this as well.

38:15.720 --> 38:20.520
So this is kind of like a conditional statement that you're putting in the beginning of your

38:20.520 --> 38:28.840
function, making sure that any code executed after line 10 is completely sure that the animal

38:28.840 --> 38:33.880
type is a cat. Okay? So in that case, you may just use a typical if statement so you don't have to

38:33.880 --> 38:41.240
do switches. Okay? But if you're trying to execute special pieces of code depending on

38:41.880 --> 38:47.240
which value this enumeration contains at the moment, then I highly suggest that you use

38:47.240 --> 38:52.920
switch statement instead of if statement. All right? So kind of depends on your use case.

38:52.920 --> 38:57.960
All right? Okay. I'm just going to mark this item as done in my notes.

38:59.960 --> 39:05.480
Now let's talk about classes. All right? Which is one of my favorite topics to talk about, actually.

39:08.440 --> 39:14.440
Well, classes in Dart and in many other languages actually bring this back to

39:14.440 --> 39:20.600
how it was before, make it a test function. All right? Remove the animal type from here.

39:27.480 --> 39:38.040
So classes in Dart are grouping of various functionalities into one packageable piece

39:38.040 --> 39:45.080
of data. And by that, I mean, for instance, let's say that you have a function called run,

39:45.720 --> 39:51.640
another function called breathe, and then you have a person's first name, a person's last name.

39:52.520 --> 39:56.920
Of course, you could go and define these things like this. You could say const first name,

39:58.600 --> 40:07.480
const last name is something like this. Okay? Goes like that. And then you could have

40:08.120 --> 40:13.560
a function, sorry, you would say run, and then you'd have another function called breathe.

40:15.960 --> 40:21.160
And you could do that. But these are functions that are kind of like for us in this particular

40:21.160 --> 40:26.920
case, or at least in my head at the moment, I am imagining these functions to be related to a person.

40:28.120 --> 40:31.560
The person can run, that person can breathe, that person has a first and a last name. So

40:31.560 --> 40:39.400
the grouping of these related things is done with a class in Dart, at least. So

40:40.280 --> 40:44.600
the way to do that is you would say, for instance, class, which is a keyword in Dart.

40:47.720 --> 40:52.200
The name of the class. Now, for the naming of classes and enumerations and any other

40:53.000 --> 40:59.720
entity except for variables and constants, you should use just normal casing. I don't actually

40:59.720 --> 41:06.120
know if it's called Pascal casing or I think so. But you would just use your uppercase,

41:06.120 --> 41:13.320
the first letter of every word. Okay? So let's just say person. Okay? This is how you would say

41:13.320 --> 41:18.920
a person class. All right? So I don't think actually we can put constants in there. I'm

41:18.920 --> 41:24.440
just going to grab these two functions and just place them inside this person class. All right?

41:25.000 --> 41:32.040
And let's in this, say, print, running, run function, and for breathing, we're going to say

41:32.040 --> 41:41.080
breathing. All right? And in the test function, you would want to create something called an

41:41.080 --> 41:48.920
instance of this class. Now, instances are objects, and objects are created from classes. So

41:49.080 --> 41:56.840
you need to understand how instantiation works in software development. And this is for any

41:56.840 --> 42:05.960
programming language such as Dart, Rust, Swift, Python, JavaScript, where they allow you to create

42:05.960 --> 42:13.800
classes. And now that you know what a class is, in order to use a class, you need to usually

42:14.680 --> 42:18.440
create something called an instance of that class. That means that you tell

42:19.000 --> 42:24.200
the programming language that, okay, here is the class. I know about that. But give me a copy of

42:24.200 --> 42:32.520
it. So every class can be instantiated, meaning that the Dart compiler will create a copy of that

42:32.520 --> 42:37.480
exact class with its data, its functions, its properties, and give that copy to you. All right?

42:38.280 --> 42:46.280
So that is called instantiation. And it works by using the equal sign and creating, putting

42:46.280 --> 42:51.400
parentheses at the end of the name of the class, as I'll show you here. So let's just say final.

42:52.760 --> 42:57.480
And we say person, which is the name of our variable in this case, is equal to,

42:57.480 --> 43:01.800
as I said, equal sign. Then you would write the name of the class and parentheses just like that.

43:02.680 --> 43:08.920
So now you said a person variable in this case is an instance of that person class. Now you'll

43:08.920 --> 43:15.400
understand using dots and notation, you could say person dot run. You see? That function is now

43:15.400 --> 43:22.680
available on your instance of the person class. And you would say person dot breathe. Okay? So

43:22.680 --> 43:30.920
these are functions that are available at instance level of the person class. I know there's a lot

43:30.920 --> 43:36.600
of words that I'm just talking about, but I think you understand the point here. So this is how you

43:36.600 --> 43:42.520
instantiate the person class, and this is how you invoke various functions on that class. So if I

43:42.520 --> 43:49.480
press command S, you can see it says running and breathing. If you said, in this case, person,

43:49.480 --> 43:56.280
and then without instantiating using the parentheses, if you said breathe, you will get

43:56.280 --> 44:03.400
an error here. Instance member breathe can't be accessed using static access. Okay? And that's,

44:03.400 --> 44:08.840
I mean, that is kind of like instance member is an important term also to remember. And instance

44:08.840 --> 44:16.520
member means some functionality that is only available at the instance level, meaning that

44:16.520 --> 44:21.240
it's not available at the person class level, but you have to make a copy of person in order to be

44:21.240 --> 44:30.600
able to access that. All right? So that's the basic of classes. You can do a lot with classes,

44:30.600 --> 44:36.760
as we will talk about soon. So I'm just going to leave that person class right there, and then

44:37.880 --> 44:45.880
just kind of mark that as talked about in my notes as well. And let's now talk a little bit

44:45.880 --> 44:53.720
about objects. Well, objects are actually quite easy to explain. An object is an instance of a

44:53.720 --> 45:01.800
class. So you wouldn't like, when someone says, oh, here's an object of type string, it means

45:01.800 --> 45:09.000
literally that there is a class called string, I've created an instance of it, and that is an

45:09.000 --> 45:17.480
object. So the words instance and object are usually used interchangeably. But if you hear

45:17.480 --> 45:22.520
someone say instantiate a class, then you would say, okay, what's the class name? Oh, it's person.

45:22.520 --> 45:29.000
All right. Person. Now I created an instance. Okay? And in this case, you can see I'm just

45:29.000 --> 45:32.520
creating an instance of person without actually doing anything with it. So that's kind of like

45:32.520 --> 45:42.520
a useless object, all right? But if I put, I say foo is a person, then this foo now is an object

45:42.520 --> 45:46.680
of type person. And actually, you can write its name here, and you'll see that it tells you that

45:46.680 --> 45:59.480
this is a person, okay? So that in short is what objects are. And I can see in my notes that

45:59.480 --> 46:04.120
objects are kind of like in the wrong place. I'm going to bring it to the right place. Sorry about

46:04.120 --> 46:16.040
that. Okay? Now let's talk a little bit about constructors. And I can see constructors also

46:16.040 --> 46:20.040
at the wrong place in my notes, so I'm going to bring those also to the right place. Okay?

46:20.840 --> 46:30.840
Sorry about that. What a constructor is at its name, as its name indicates, is a special logic

46:30.840 --> 46:38.920
in a class that constructs or initializes or builds that class's instance, all right? So

46:39.720 --> 46:43.800
you may say that, okay, let's go to our function here, to our class here, person.

46:44.440 --> 46:50.840
And let's say every person has a first name or a name, okay? So let's just define that. We say

46:50.840 --> 46:56.440
final string name, all right? As you can see now, Dart is saying, okay, you said that every person

46:56.440 --> 47:03.000
has a name, and it's a final, meaning that after the person has been instantiated or after that

47:03.000 --> 47:09.000
person has been initialized or created an instance from, you cannot change that name because you said

47:09.000 --> 47:15.400
final, all right? If you said string name is foo, that would be different because it means

47:15.400 --> 47:21.240
every person instance that gets created has the default value foo for its name. That's a completely

47:21.240 --> 47:26.680
different way of saying what the name of the person is. In this case, as you can see, we're

47:26.680 --> 47:33.000
saying that every person instance, every person copy that we create has a name. Now Dart is saying,

47:33.000 --> 47:38.520
okay, where is the name then? You didn't tell me how to create it. And that's where you would

47:38.520 --> 47:46.200
want to use something called constructor, okay? Constructors are sometimes called as initializers.

47:46.200 --> 47:50.680
Depending on the background of the programmer, they may call it constructor initializer

47:51.400 --> 47:55.880
or maybe some other names that I don't know about. But if you hear that, a constructor,

47:55.880 --> 48:04.040
then you will now know what I'm talking about soon actually. So now what you can do, at least

48:04.040 --> 48:10.120
in Visual Studio Code, when you get this error is to just hover over it and then press command

48:10.120 --> 48:17.000
on Mac or control on Windows or Linux and press dot. Now you will see you will get some suggestions

48:17.000 --> 48:22.120
here. And the second suggestion, at least for me here, it says create constructor for final

48:22.120 --> 48:28.200
fields, okay? And I can just press that. And what happens here now, you see it's that it creates

48:28.200 --> 48:35.240
something that looks kind of like a function, but it doesn't have a name. Its name is implicitly

48:35.240 --> 48:41.400
set to the name of the class, okay? So basically, it says I'm a special function with the same name

48:41.400 --> 48:49.480
as the class, and I expect a value to be given to me, which I will then in turn assign to the name

48:49.480 --> 48:56.760
property of myself. It's kind of like a strange way of doing things, but is quite clean as well,

48:56.760 --> 49:02.280
okay? After you do that, so this is how you create a constructor. After you do that, then at the call

49:02.280 --> 49:07.880
site where you're calling this person class to create an instance of it, it will complain saying

49:07.880 --> 49:14.360
that, oh, I'm expecting an argument, but I didn't find any. And that's where you have to pass the

49:14.360 --> 49:21.400
name. So let's say in this case is foo bar, okay? And then on the next line, you can just say print

49:21.400 --> 49:27.880
foo name, all right? And press command S, and then you can see foo bar being printed to the screen.

49:27.880 --> 49:34.760
So that is like the basic of a constructor. That's how you construct instances of your class,

49:34.760 --> 49:41.400
all right? Now, you may be saying that, all right, I don't want, I mean, you can do many fancy things

49:41.400 --> 49:49.000
with constructors. You could say, okay, its name, for instance, by default, must have a special

49:49.000 --> 49:52.680
value. You could do that. There's lots of things you can do with constructors, which I'm not going

49:52.680 --> 49:58.280
to go into the details of. But right now, just know that a constructor is this special kind of

49:58.280 --> 50:03.560
function that has the same name as the name of the class, and then parentheses, and then you put your

50:03.560 --> 50:17.960
values in here, all right? Okay, that was constructors. Now, let's talk a little bit about

50:19.560 --> 50:28.840
methods, all right? And what methods are, I'm actually going to go here and say, we're going

50:28.840 --> 50:33.960
to talk about methods. I know it's at the wrong place in my notes as well. Sorry about that.

50:33.960 --> 50:40.280
A method of a class we've talked about already, to be honest with you, and a method of a class is

50:40.360 --> 50:49.960
a function on the class, which is usually referred to as an instance method, meaning that the

50:49.960 --> 50:55.080
function is available after you've instantiated that class, all right, as we're doing in line

50:55.080 --> 51:03.720
number 14. Name is an instance variable. So, is a variable that is available at an instance level

51:03.720 --> 51:09.800
is not an instance method. An instance method should be a function, all right? So, let's go

51:09.800 --> 51:15.000
and create a function here that doesn't return any value denoted by the void return type, and we

51:15.000 --> 51:22.760
say print name, all right? The functionality of this function is only just to print the name of

51:22.760 --> 51:28.600
the class, all right? That's all it does. And in Dart, you're also, now that we're talking about

51:28.600 --> 51:35.320
this, I'll just mention also that in Dart it's usually better not to prefix your instance

51:35.320 --> 51:46.840
variables or instance functions inside the class itself using this keyword. This keyword in Dart,

51:48.440 --> 51:57.800
the this this or that this keyword basically refers to the current instance of this class,

51:57.800 --> 52:04.840
all right? So, you can either tell print name to print this dot name, or it's actually better

52:04.840 --> 52:09.880
to remove this and refer to it as name. That's the recommended way of doing it, okay? So,

52:09.880 --> 52:17.240
avoid the keyword this as much as you can unless you have to. And we'll come to those points

52:17.240 --> 52:23.400
hopefully later in this course why you may have to do that, why you may have to use this.

52:24.920 --> 52:32.120
All right. Now we have the print name instance method, all right? So, let's just use it. Instead

52:32.120 --> 52:38.360
of this print function that we're doing here, let's just say foo dot print's name, all right?

52:38.360 --> 52:45.800
Command S or Control S on Linux and Windows and Command S on Macintosh, and then you get the

52:45.800 --> 52:54.680
Flutter foo bar printed here. Or you could just say print, I'm going to, I will now print the name

52:54.680 --> 53:00.120
of this person in single quotes. We don't need double quotes, okay? Command S and you will see

53:00.120 --> 53:04.920
that message being printed here, followed by the actual name of that instance. So,

53:05.480 --> 53:10.440
if someone says method or instance message, you will then know what we're talking about.

53:10.440 --> 53:16.280
It's a function created at the class level that does some stuff, all right? So, that's short and

53:16.280 --> 53:27.000
sweet. Okay. Now that we've talked about that, let's talk a little bit about inheritance and

53:27.000 --> 53:31.480
subclassing. I'm going to bring the caption here so you know what we're talking about.

53:33.000 --> 53:41.320
Now, inheritance and subclassing are so, so important in Dart and in any other object-oriented

53:41.320 --> 53:46.600
programming language that I don't think anybody should jump over it. Like, for instance, I know

53:47.320 --> 53:52.120
developers working in various programming languages that are object-oriented, but they kind of steer

53:52.120 --> 53:58.440
clear of the object-oriented aspects of that language. Maybe they don't need it and maybe

53:58.440 --> 54:03.480
they just feel like it's unnecessary or they feel like, oh, it's just too complicated.

54:03.480 --> 54:08.520
But in Dart, if you want to become a good Flutter developer or a good Dart developer, you need to

54:08.520 --> 54:20.920
know about classes and inheritance. So, let's talk about inheritance. What inheritance in Dart is,

54:20.920 --> 54:30.200
is that it allows you to define a class and then to add more functionality to that class

54:31.000 --> 54:41.000
into a new class. So, let's, for instance, say we go into our test function here and remove that,

54:41.080 --> 54:50.360
okay, that code, and also remove the person class. Now, let's create a class living thing,

54:50.360 --> 55:00.920
all right, and then we say void, breathe, and then we say print. Living thing is breathing,

55:00.920 --> 55:07.400
okay? So, we created a class living thing, and we're saying that anything that lives needs to

55:07.400 --> 55:12.440
breathe. Now, this may be an assumption, but anyways, anything that lives and is above the

55:14.600 --> 55:21.640
ground and is basically alive is breathing, okay? So, that's our function on the living thing. Now,

55:22.440 --> 55:29.240
you may say, okay, any living thing may also have the ability to move, okay? Then we have

55:29.240 --> 55:36.600
a function called move. I'm going to say print, I am moving, all right? So, now you may say, okay,

55:36.600 --> 55:44.120
now I kind of want a class called cat, all right. Cat is also a living thing. One way to do that,

55:44.120 --> 55:51.160
to go about creating a class, the cat class is to say class cat, and then you say, hmm,

55:51.160 --> 55:55.720
I kind of need these functions, and you'll go and copy it, and then you paste them here,

55:55.720 --> 56:04.920
all right? And then you say, okay, I'm good to go now. But one of the absolute paramount qualities

56:04.920 --> 56:13.960
of a developer is that developers do not like to repeat themselves, and it is such an important

56:13.960 --> 56:18.600
concept in programming that you need to avoid repeating yourself, that you need to just coin

56:18.600 --> 56:25.000
that down now, get it straight so that you don't make this mistake as we're doing in this code

56:25.000 --> 56:30.760
right now. So, the first thing you want to do as a developer is say, how can I grab this code?

56:31.480 --> 56:38.520
And it's obvious that the cat is also a living thing. So, that's where you want to use the

56:38.520 --> 56:46.360
extends keyword that allows you to inherit the functionality inside the living thing class

56:46.360 --> 56:53.000
into your cat class. So, in this case, I'm saying cat class extends or read it in English as inherits

56:53.720 --> 57:00.040
living thing, all right? So, you can see that the cat class in itself is empty right now,

57:00.040 --> 57:10.520
but if you go to the test function and I say, final, fluffers is a cat, and then I can say

57:10.520 --> 57:18.600
fluffers, you can see that now that the cat class has breathe and move functionalities,

57:18.600 --> 57:24.200
or functions, actually. So, although cat itself didn't define these functions,

57:24.200 --> 57:30.760
but they're available for the instance in this case called fluffers of type cat to use. So,

57:30.760 --> 57:38.040
you can just say move, and then you can say fluffers, okay? So, if I run this code,

57:38.040 --> 57:42.360
if I delete everything in the debug console and run this code, you can see that the cat

57:42.360 --> 57:47.800
instance called fluffers is saying move, or I am moving, and it will also say living thing is

57:47.800 --> 57:58.680
breathing, okay? Now, we could also talk about, now that we're talking about inheritance and

57:58.680 --> 58:05.160
subclassing. Actually, maybe I shouldn't call it subclassing, but I also think it's important

58:05.160 --> 58:08.680
for you to understand what subclassing is. Subclassing is literally the same thing as

58:08.680 --> 58:13.160
inheritance. Subclassing is saying that you have a class and you're creating a subcomponent, like a

58:13.160 --> 58:20.440
subthing of it, which may actually have, it's a little bit of a strange name in sub because

58:20.440 --> 58:26.280
sub means kind of like a subset of things available in that class, but it actually is like a superset

58:26.280 --> 58:32.600
because it will grab everything, like the cat at the moment has every functionality in living thing,

58:32.600 --> 58:39.240
right? But it may not necessarily do that. It's kind of complicated to explain, but if you hear

58:39.240 --> 58:48.600
subclassing or inheritance, know that that is what we mean. You use the extents keyword, usually,

58:48.600 --> 58:56.600
okay? All right. Now, we've talked about inheritance and subclassing.

58:58.520 --> 59:06.040
So, I'm gonna move a little bit my notes around, sorry about that, that I'm looking away from the

59:06.040 --> 59:14.760
screen, and now we're gonna talk about abstract classes, all right? There's good documentation

59:14.760 --> 59:24.520
about abstract classes, and what we're gonna do here is to just change this class living thing

59:24.520 --> 59:35.480
at the moment to abstract, and you'll see that everything works as expected. Well, an abstract

59:35.480 --> 59:43.720
class is very similar to a normal class, and there's good documentation about what an abstract

59:43.720 --> 59:48.280
class actually is from a Dart perspective, and you can see it says use the abstract modifier to

59:48.280 --> 59:56.200
define an abstract class that cannot be instantiated, all right? So, an abstract class is just like a

59:56.200 --> 59:59.480
normal class that can't have instances. So,

